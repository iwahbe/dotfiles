#+AUTHOR: iwahbe
#+PROPERTY: header-args :noweb no-export :mkdirp t
#+PROPERTY: header-args:emacs-lisp :tangle .emacs.d/init.el
#+PROPERTY: header-args:zsh :tangle .zshrc :shebang "#!/bin/zsh"

* Literate Configuration

We want to be able to treat this file especially, so we need to set its name in a variable.

#+BEGIN_SRC emacs-lisp :var this-file=(buffer-file-name)
(defvar =literate-config-file this-file
  "The file that this config was tangled from.")
#+END_SRC

Common file types have common headers and footers. [[help:org-babel-tangle][org-babel-tangle]] has support for post-tangle hooks, but doesn't expose a framework for such hooks. We want such a framework.

Org-babel exposes [[help:org-babel-post-tangle-hook][org-babel-post-tangle-hook]]. We can build a macro on top of that to create easy finalize hooks.

#+BEGIN_SRC emacs-lisp
(defmacro =config-tangle-finalize (&rest body)
  "Define a function to run after tangling a file in this directory.

The first argument to BODY specifies the condition to run the
hook.  Available patterns are:

- (`:ext' EXT): EXT is a symbol that defines the extension for the file.
- (`:name' NAME): NAME is a symbol that specifies the full name of the file.
- (`or' PAT1 ... PATN): PAT_I is one of the available patterns."
  (declare (indent defun))
  (let ((f `(buffer-file-name)))
    `(add-hook 'org-babel-post-tangle-hook
	       (lambda ()
		 (when (and
			(string-prefix-p (expand-file-name
					  (file-name-directory =literate-config-file))
					 ,f)
			,(=config--tangle-condition (car body) f))
		   ,@(cdr body)
		   ;; We need to save the buffer, since this hook runs after the initial
		   ;; babel save
		   (let ((save-silently t) before-save-hook)
		     (save-buffer)))))))
#+END_SRC

The bulk of the work is parsing the condition. We need to define a separate function here because the definition is recursive.

#+BEGIN_SRC emacs-lisp
(defun =config--tangle-condition (condition file-name)
  "Parse CONDITION into a callable function.
FILE-NAME evaluates to the file name under consideration."
  (pcase condition
    (`(:ext ,ext) `(equal (file-name-extension ,file-name t) (symbol-name ',ext)))
    (`(:name ,name) `(equal (file-name-nondirectory ,file-name) (symbol-name ',name)))
    (`(or . ,l) `(or ,@(mapcar (lambda (x) (=config--tangle-condition x file-name)) l)))
    (other (error "Unknown condition: '%s'" other))))
#+END_SRC


Referencing and editing our configuration is a common action (for good or for ill). We bind config navigation.

#+BEGIN_SRC emacs-lisp
(defun =config-heading ()
  "Jump to a config heading."
  (interactive)
  (require 'org)
  (org-overview)
  (consult-org-heading nil `(,=literate-config-file))
  (org-reveal)
  (org-fold-show-subtree))

(global-set-key (kbd "C-c C") #'=config-heading)
#+END_SRC

We don't actually want to tangle this file into its surrounding directory. We want to tangle it into the output directory.

#+BEGIN_SRC emacs-lisp
(advice-add #'org-babel-effective-tangled-filename :around
	    (lambda (fn buffer-fn src-lang src-tfile)
	      "Ensure that all files tangled from readme.org are emmited to the output directory."
	      (let ((v (funcall fn buffer-fn src-lang src-tfile)))
		(if (and v (equal buffer-fn "readme.org")
			 (not (string-prefix-p "bin/" src-tfile)))
		    (concat "output/" v)
		  v))))
#+END_SRC

** CLI
#+PROPERTY: header-args:sh :tangle bin/config :shebang "#!/bin/sh"

We want to provide a script to link generated files into the main directory. Instead of trying to track the files generated during tangling, we provide a simple =sh= script to recursively traverse a directory, adding symlinks as appropriate. We do this with a script instead of a =emacs-lisp= function to ensure that tangled artifacts can be produced without a fully configured Emacs instance.

We begin by defining our /action/ functions. These are the functions that will actually perform work.

#+BEGIN_SRC sh
# make_link <src> <dst>
#
# Create a link between <src> and <dst>.
# <src> may be a directory.
# <dst> will not exist.
#
# You can override the command used by setting CONFIG_LINK_CMD.
make_link () {
    if [[ "" == "$CONFIG_LINK_CMD" ]]; then
	echo "Linking $1 to $2: done"
	ln -s -w $1 $2
    else
	$CONFIG_LINK_CMD $1 $2
    fi
}

# unmake_link <src> <dst>
#
# Remove an existing link from <src> to <dst>.
#
# You can override the command used by setting CONFIG_UNLINK_CMD.
unmake_link() {
    if [[ "" == "$CONFIG_UNLINK_CMD" ]]; then
	echo "Unlinking $1 from $2: done"
	rm $2
    else
	$CONFIG_UNLINK_CMD $1 $2
    fi
}

# skip_link <src> <dst>
#
# Skip linking from <src> to <dst> because <dst> already exists.
skip_link() {
    # echo "skiping linking $1 to $2"
    true # Necessary because empty functions are not allowed in sh scripts.
}
#+END_SRC

We define defaults for both =$SRC_DIR= and =$DST_DIR=. We define them separately because we will show these defaults in our help message.

#+BEGIN_SRC sh
SRC_DEFAULT_DIR="$PWD/output" # This is chosen so running bin/config up "just works"

DST_DEFAULT_DIR="$HOME"
#+END_SRC

We then define our =$HELP= variable, using [[https://tldp.org/LDP/abs/html/here-docs.html][heredoc]].

#+BEGIN_SRC sh
read -r -d '' HELP <<- EOF
	config [cmd] [src=$SRC_DEFAULT_DIR] [dst=$DST_DEFAULT_DIR]

	Recursivly link src to dst. Effert is made to make the minimum number of links.
	That means that directories are linked if possible, otherwise their content is recursed.

	Files in dst are prioritized over files in src.

	Both src and dst must be directories.
EOF
#+END_SRC

Here we translate our CLI arguments =$1= (=[src]=) and =$2= (=[dst]=) into local variables, initialize them to their default values, or make relative paths absolute.

#+BEGIN_SRC sh
SRC_DIR=$2
DST_DIR=$3

if [[ "$SRC_DIR" == "" ]]; then
    # If the source directory is empty, apply the default.
    SRC_DIR="$SRC_DEFAULT_DIR"
elif [[ ! "$SRC_DIR" == /* ]]; then
    # If the source directory doesn't start with a slash, prefix it with the current
    # directory
    SRC_DIR="$PWD/$SRC_DIR"
fi

if [[ "$DST_DIR" == "" ]]; then
    DST_DIR="$DST_DEFAULT_DIR"
elif [[ ! "$DST_DIR" == /* ]]; then
     # If a relative directory was given, set it relative to the current directory.
     DST_DIR="$PWD/$DST_DIR"
fi
#+END_SRC

If they were not initialized to valid directories, then the user made a mistake invoking the command. We show help and exit.

#+BEGIN_SRC sh
if [[ ! -d "$SRC_DIR" ]]; then
    echo "'$SRC_DIR' is not a directory"
    echo
    echo "$HELP"
    exit 1
fi

if [[ ! -d "$DST_DIR" ]]; then
    echo "'$DST_DIR' is not a directory"
    echo
    echo "$HELP"
    exit 1
fi
#+END_SRC

=stand_up= implements the recursive linker. The algorithm is simple:

For a directory, check
- If the destination does not exist, link it and return.
- If the destination is a directory and the source is a directory, recurse
- If the destination is already linked to the source, return.
- Otherwise skip the link and return.

#+BEGIN_SRC sh
# stand_up <path>
stand_up () {
    if [[ ! -e "$DST_DIR/$1" ]] && [[ ! -L "$DST_DIR/$1" ]]; then
	# dst doesn't exist, so link the entry.  This can be either a file or a
	# directory.
	make_link "$SRC_DIR/$1" "$DST_DIR/$1"
    elif [[ -d "$DST_DIR/$1" ]] && [[ -d "$SRC_DIR/$1" ]]; then
	# The dst directory exists,
	for entry in $('ls' -a "$SRC_DIR/$1"); do
	    if [[ "$entry" == "." ]] || [[ "$entry" == ".." ]]; then
		true # do nothing here
	    elif [[ "$1" == "" ]]; then
		stand_up "$entry"
	    else
		stand_up "$1/$entry"
            fi
	done
    elif [[ -L "$DST_DIR/$1" ]] && [[ "$(readlink $DST_DIR/$1)" == "$SRC_DIR/$1" ]]; then
	echo "Linking $DST_DIR/$1: already linked"
    else
	# We can't recurse down directories, so we give up
	skip_link "$SRC_DIR/$1" "$DST_DIR/$1"
    fi
}
#+END_SRC

=tear_down= implements the algorithm for recursively removing links. The algorithm goes:

For a directory:
- If the destination is a link to the source, remove the link and return.
- Otherwise if the source and destination are directories, recurse into the directory.

#+BEGIN_SRC sh
# tear_down <path>
tear_down () {
    if [[ -L "$DST_DIR/$1" ]] && [[ "$(readlink $DST_DIR/$1)" == "$SRC_DIR/$1" ]]; then
	# Its a link to the file in our tree
	unmake_link "$SRC_DIR/$1" "$DST_DIR/$1"
    elif [[ -d "$DST_DIR/$1" ]] && [[ -d "$SRC_DIR/$1" ]]; then
	# The dst directory exists,
	for entry in $('ls' -a "$SRC_DIR/$1"); do
	    if [[ "$entry" == "." ]] || [[ "$entry" == ".." ]]; then
		true # do nothing here
	    elif [[ "$1" == "" ]]; then
		tear_down "$entry"
	    else
		tear_down "$1/$entry"
	    fi
	done
    fi
}
#+END_SRC

Finally, we have a switch statement that controls the command's execution.

#+BEGIN_SRC sh
case $1 in
    up)
	stand_up ""
	;;
    down)
	tear_down ""
	;;
    ,*)
	echo "Unknown command \"$1\""
	echo ""
	echo "$HELP"
	;;
esac
#+END_SRC

* Emacs
** Getting Started

*** Installation

On mac, I use [[https://github.com/d12frosted/homebrew-emacs-plus][homebrew-emacs-plus]] to install Emacs. This is the command I used to install.

#+BEGIN_SRC sh :tangle bin/brew.sh
brew install emacs-plus@29     \
     --with-no-frame-refocus   \
     --with-imagemagick        \
     --with-native-comp        \
     --with-poll               \
     --with-memeplex-wide-icon
#+END_SRC

** Literate Configuration

This is a [[http://www.literateprogramming.com][literate]] [[help:user-emacs-directory][config]] for Emacs. This file is the single source of truth for the contents of =.emacs.d=.

We want all =emacs-lisp= files to be tangled with the appropriate headers and footers.

- Emacs would like each file to declare its module, and a description.
- All files should use lexical bindings. This makes the code easier to read, and easier for Emacs to interpret, leading to a performance boost.
- Emacs would like each file to declare its end.

#+BEGIN_SRC emacs-lisp
(=config-tangle-finalize (:ext .el)
  (let ((feature (string-remove-suffix
		  ".el" (string-remove-prefix
			 (expand-file-name user-emacs-directory)
			 (buffer-file-name)))))
    ;; Insert the header
    (goto-char (point-min))
    (insert ";;; " feature ".el --- Tangled from init.org -*- lexical-binding: t; -*-\n"
	    "\n"
	    ";;; Commentary:\n"
	    "\n"
	    ";; This file was tangled as part of iwahbe's Emacs config.\n"
	    "\n"
	    ";;; Code:\n"
	    "\n")
    ;; Then insert the footer
    (goto-char (point-max))
    (insert "\n"
	    "(provide '" feature ")\n"
	    ";;; " feature ".el ends here\n"))
  (lisp-indent-region (point-min) (point-max)))
#+END_SRC

Further, we want lexical bindings even when developing interactively. This doesn't do anything when a file is loaded, but it does effect what happens when =eval-last-sexp= is used.

#+BEGIN_SRC emacs-lisp
(setq-default lexical-binding t)
#+END_SRC

I declare a custom helper macro for adding hooks. It simplifies quoting, and allows multiple hooks to be attached in a single /sexp/.

#+BEGIN_SRC emacs-lisp
(defmacro =add-hook (mode &rest hooks)
  "Attach multiple HOOKS to a MODE hook.
It is optional to quote MODE."
  (declare (indent defun))
  `(progn
     ,@(mapcar
	(lambda (hook) `(add-hook
			 ,(if (eq (car-safe mode) 'quote)
			      mode
			    `(quote ,mode))
			 ,hook))
	hooks)))
#+END_SRC

==dbg= isn't used within the config, but it proves a helpful pass-through macro for debugging.

#+BEGIN_SRC emacs-lisp
(defmacro =dbg (form)
  "Print FORM => RES where res is what FORM evaluate to.
Return RES."
  `(let ((res ,form)) (message "dbg: %s => %s" '(,@form) res) res))
#+END_SRC


=(==one-of el p1 p2)= is an efficient implementation of =(memq el (list p1 ... pN))= where =p_i= is computed only for the equality check.

#+BEGIN_SRC emacs-lisp
(defmacro =one-of (el &rest forms)
  "Check if EL is one of FORMS.
The nth form in FORMS is evaluated only if no previous form matched EL.
Each form in FORMS is compared against EL with `eq'."
  (let ((name (gensym "el")))
    `(let ((,name ,el))
       (or ,@(mapcar
	      (lambda (form)
		`(eq ,name ,form))
	      forms)))))
#+END_SRC

The best way to understand how ==one-of= works is too see what it expands into:

#+BEGIN_SRC emacs-lisp :tangle no :results pp :wrap example emacs-lisp
(macroexpand-1
 `(=one-of (get-input) (comp1) (comp2) (comp3)))
#+END_SRC

#+RESULTS:
#+begin_example emacs-lisp
(let
    ((el39
      (get-input)))
  (or
   (eq el39
       (comp1))
   (eq el39
       (comp2))
   (eq el39
       (comp3))))
#+end_example

** Performance

Emacs Lisp is garbage collected. While this is generally fine, I don't need garbage collection runs kicking off during startup. I disable garbage collection during startup.

It is important that we turn off the GC as early as possible, to save as many cycles as possible.

#+BEGIN_SRC emacs-lisp :tangle .emacs.d/early-init.el
(setq gc-cons-threshold most-positive-fixnum
      gc-cons-percentage 0.6)
#+END_SRC

We don't want to permanently disable garbage collection, so we re-enable garbage collection after all packages have been loaded.

#+BEGIN_SRC emacs-lisp
(add-hook 'elpaca-after-init-hook
	  (lambda ()
	    (setq gc-cons-threshold 16777216 ; 16mb
		  gc-cons-percentage 0.1)))
#+END_SRC

** Window + Frame Management

A quick glossary for those new to Emacs. Because Emacs predates windowed graphics systems, it uses different terminology then the rest of the world.

In Emacs parlance, the object managed by the OS windowing system is called a *frame*. Each internal pane in a /frame/ is called a *window*.

By default, Emacs thinks in terms of text columns and lines. This isn't great when computing frame sizes for graphical purposes. We want to think in pixels.

#+BEGIN_SRC emacs-lisp :tangle .emacs.d/early-init.el
(setq frame-resize-pixelwise t)
#+END_SRC

It is important to set graphical elements in =early-init.el=, since otherwise they take effect after graphics open and the window viably flickers or resizes.

#+BEGIN_SRC emacs-lisp :tangle .emacs.d/early-init.el
(tool-bar-mode -1)
(menu-bar-mode -1)
(setq
 frame-resize-pixelwise t
 ;; We set the font here to work around a bug that hides the echo area
 ;; when a font is set after the frame loads.
 default-frame-alist '((font . "Fira Code")
		       (vertical-scroll-bars . nil)
		       (horizontal-scroll-bars . nil))
 initial-frame-alist
      '((width . 0.5) (height . 1.0)
	(top . 0) (left . 1.0)))
#+END_SRC

** Clutter Management

We want to be able to cleanly check this file in so we direct what we can into a hidden =.cache=.

#+BEGIN_SRC emacs-lisp
(defvar =cache-directory (expand-file-name ".cache" user-emacs-directory)
  "The directory where a system local cache is stored.")

(defun =cache-subdirectory (domain)
  "A stable directory to cache files from DOMAIN in."
  (expand-file-name (concat domain "/") =cache-directory))

(defun =cache-file (file &optional domain)
  "A stable file name for FILE, located in DOMAIN if provided."
  (expand-file-name file
		    (if domain
			(let ((s (=cache-subdirectory domain)))
			  (unless (file-executable-p s)
			    (mkdir s))
			  s)
		      =cache-directory)))
#+END_SRC

In theory, it is possible to redirect =.eln= files to an arbitrary location using =startup-redirect-eln-cache=, but it hasn't worked for me. For the record, this is the block I tried:

#+BEGIN_SRC emacs-lisp :file .emacs.d/early-init.el :tangle no
(when (fboundp 'startup-redirect-eln-cache)
  (startup-redirect-eln-cache (=cache-subdirectory "eln-cache")))
#+END_SRC

Following good practice, we maintain an =assets= folder, where we store /heavy/ files.

#+BEGIN_SRC emacs-lisp
(defvar =assets-directory (expand-file-name "assets" user-emacs-directory)
  "The directory containing large runtime assets, such as images.")
#+END_SRC

Part of clutter management is keeping file buffers up to date with the underlying files. For this, we have [[help:auto-revert-mode][auto-revert-mode]].

#+BEGIN_SRC emacs-lisp
(auto-revert-mode +1)
#+END_SRC

** Package Management

I use [[https://github.com/progfolio/elpaca][elpaca]] as my package manager for Emacs. Like all package managers (except built-in =package.el=, it requires a self-install script to initialize itself.

To avoid cluttering up the =.emacs.d= directory, we have =elpaca= cache in it's own directory.

#+BEGIN_SRC emacs-lisp
(defvar elpaca-directory (=cache-subdirectory "elpaca"))
  #+END_SRC

  This is the install script from the elpaca repo:

#+BEGIN_SRC emacs-lisp
(defvar elpaca-installer-version 0.1)
(defvar elpaca-builds-directory (expand-file-name "builds/" elpaca-directory))
(defvar elpaca-order '(elpaca :repo "https://github.com/progfolio/elpaca.git"
			      :ref nil
			      :files (:defaults (:exclude "extensions"))
			      :build (:not elpaca--activate-package)))
(when-let ((repo  (expand-file-name "repos/elpaca/" elpaca-directory))
	   (build (expand-file-name "elpaca/" elpaca-builds-directory))
	   (order (cdr elpaca-order))
	   ((add-to-list 'load-path (if (file-exists-p build) build repo)))
	   ((not (file-exists-p repo))))
  (condition-case-unless-debug err
      (if-let ((buffer (pop-to-buffer-same-window "*elpaca-installer*"))
	       ((zerop (call-process "git" nil buffer t "clone"
				     (plist-get order :repo) repo)))
	       (default-directory repo)
	       ((zerop (call-process "git" nil buffer t "checkout"
				     (or (plist-get order :ref) "--"))))
	       (emacs (concat invocation-directory invocation-name))
	       ((zerop (call-process emacs nil buffer nil "-Q" "-L" "." "--batch"
				     "--eval" "(byte-recompile-directory \".\" 0 'force)"))))
	  (progn (require 'elpaca)
		 (elpaca-generate-autoloads "elpaca" repo)
		 (kill-buffer buffer))
	(error "%s" (with-current-buffer buffer (buffer-string))))
    ((error) (warn "%s" err) (delete-directory repo 'recursive))))
(require 'elpaca-autoloads)
(add-hook 'after-init-hook #'elpaca-process-queues)
(elpaca `(,@elpaca-order))
#+END_SRC

Worth noting: =elpaca= runs asynchronously, and kicks off after =after-init-hook=.

We need to disable =package.el=, Emacs's default package manager. Since =package.el= sets up existing packages before =init.el= runs, we need to do this in =early-init.el=:

#+BEGIN_SRC emacs-lisp :tangle .emacs.d/early-init.el
(setq package-enable-at-startup nil)
#+END_SRC

** Splash Screen

Half of customizing Emacs is making the splash screen look fancy.

We redefine =display-startup-echo-area-message=, since there is no built in way to disable it. To make sure I am cognizant of start-up time, I have this set to display the load time of Emacs.

#+BEGIN_SRC emacs-lisp
(defun display-startup-echo-area-message ()
  "Override the default help message by redefining the called function."
  (message "Loaded %s packages in %f seconds"
	   (length (elpaca--queued))
	   (float-time
	    (time-subtract
	     elpaca-after-init-time
	     before-init-time))))
#+END_SRC

I like the simplicity of a random Emacs-related image on screen. I'm not willing to give up on supporting text only situations (such as in the terminal). To that end, there is a fall-back option to display only text.

#+BEGIN_SRC emacs-lisp
(defun =splash-buffer (&optional window)
  "The splash screen.
It is assumed that the splash screen will occupy the whole frame
when it is created.
WINDOW is passed via `window-size-change-functions'.  It is ignored."
  (ignore window)
  (if (not (=one-of (current-buffer)
	    (get-buffer "*scratch*")
	    (get-buffer "*Splash Screen*")))
      ;; If the current buffer is not *scratch*, then Emacs was opened
      ;; onto a file, so we should just display that file.
      (current-buffer)
    (with-current-buffer (get-buffer-create "*Splash Screen*")
      (read-only-mode)
      (make-local-variable 'window-size-change-functions)
      (add-to-list 'window-size-change-functions #'=splash-buffer)
      (let ((inhibit-read-only t))
	(unless (eq (buffer-size) 0)
	  (erase-buffer))
	(if (and (display-graphic-p) (featurep 'image))
	    (=splash-buffer--graphic)
	  (=splash-buffer--text))
	(setq cursor-type nil)
	(goto-char (point-min))
	(setq mode-line-format nil)
	(current-buffer)))))
#+END_SRC

Emacs uses =initial-buffer-choice= to determine what buffer it should start in.

#+BEGIN_SRC emacs-lisp
(setq initial-buffer-choice #'=splash-buffer)
#+END_SRC

*** Graphics

Here we want to insert a random image from our list of graphic banner images. Graphic banner images are stored in the =assets= folder. We define our list of images.

#+BEGIN_SRC emacs-lisp
(defvar =emacs-graphic-banners
  (mapcar (lambda (x) (expand-file-name x =assets-directory))
	  '("gnu-head.svg"
	    "emacs-icon.svg"))
  "A list of graphical banners to open Emacs with.
Each element is expected to be the path to a SVG file.")

(defvar =emacs-graphic-banner
  (nth (random (length =emacs-graphic-banners))
       =emacs-graphic-banners)
  "The randomly chosen graphic banner to use for this session.
This is calculated once, so it doesn't change during redisplay.")
#+END_SRC

We then define what a graphic splash buffer will be: A centered image 1/3 down the frame.

#+BEGIN_SRC emacs-lisp
(defun =splash-buffer--graphic ()
  "Display the splash screen with graphics."
  (let* ((img
          ;; Each image is expected to take up 3/4 of the smallest dimension of screen
          ;; space.
          (if (>= (frame-pixel-width) (frame-pixel-height))
              (create-image
	       =emacs-graphic-banner
	       nil nil :height (round (* (frame-pixel-height) 0.75)))
	    (create-image
	     =emacs-graphic-banner
	     nil nil :width (round (* (frame-pixel-width) 0.75)))))
	 (img-size (image-size img))
	 (img-width (round (car img-size)))
	 (img-height (round (cdr img-size))))
    ;; We want to center the image around 1/3 down the
    ;; screen. Since the image insert holds the top of the
    ;; image, we need to adjust the insert point by adding
    ;; newlines.
    (insert (make-string (max (- (/ (frame-height) 3) (/ img-height 2)) 0) ?\n))
    ;; Likewise, we want to insert the image in the center of
    ;; the screen but the image inserts from the left. We pad
    ;; our insert point with spaces.
    (insert (make-string (max (- (/ (frame-width) 2) (/ img-width 2)) 0) ? ))
    (insert-image img nil nil nil t)))
    #+END_SRC

*** Text

Text banners are stored inline with in =init.el=. They were generated from [[https://patorjk.com/software/taag/#p=display&f=Graffiti&t=Emacs][patorjk.com/software/taag]].

#+BEGIN_SRC emacs-lisp
(defvar =emacs-text-banners
  '(("███████╗███╗   ███╗ █████╗  ██████╗███████╗"
     "██╔════╝████╗ ████║██╔══██╗██╔════╝██╔════╝"
     "█████╗  ██╔████╔██║███████║██║     ███████╗"
     "██╔══╝  ██║╚██╔╝██║██╔══██║██║     ╚════██║"
     "███████╗██║ ╚═╝ ██║██║  ██║╚██████╗███████║"
     "╚══════╝╚═╝     ╚═╝╚═╝  ╚═╝ ╚═════╝╚══════╝")
    ("  _______  ___      ___       __       ______    ________  "
     " /\"     \"||\"  \\    /\"  |     /\"\"\\     /\" _  \"\\  /\"       ) "
     "(: ______) \\   \\  //   |    /    \\   (: ( \\___)(:   \\___/  "
     " \\/    |   /\\\\  \\/.    |   /' /\\  \\   \\/ \\      \\___  \\    "
     " // ___)_ |: \\.        |  //  __'  \\  //  \\ _    __/  \\\\   "
     "(:      \"||.  \\    /:  | /   /  \\\\  \\(:   _) \\  /\" \\   :)  "
     " \\_______)|___|\\__/|___|(___/    \\___)\\_______)(_______/   "))
  "A list of non-graphical banners.
Each banner is expected to be a list of text, where each text
element is a single line.")

(defvar =emacs-text-banner
  (nth (random (length =emacs-text-banners)) =emacs-text-banners)
  "The text banner to use for this session.
This is calculated once so it doesn't change during redisplay")
#+END_SRC

The display function is similar to the graphic version, aiming to put the text centered 1/3 down the frame.

#+BEGIN_SRC emacs-lisp
(defun =splash-buffer--text ()
  "Display the splash screen with only text."
  (let ((banner =emacs-text-banner)
	(empty-line "\n"))
    (dotimes (_ (- (/ (frame-height) 3) (/ (length banner) 2) 2))
      (insert empty-line))
    (mapc (lambda (x) (insert x "\n")) banner))
  (let ((fill-column (frame-width)))
    (center-region (point-min) (point-max))))
#+END_SRC

** UX

I understand what the scratch buffer does, so the explanation is not necessary.

#+begin_src emacs-lisp
(setq initial-scratch-message nil)
#+end_src

I don't need the additional delay of typing "es" or "o". "y" or "n" is sufficient.

#+BEGIN_SRC emacs-lisp
(fset #'yes-or-no-p #'y-or-n-p)
#+END_SRC

Text editors should not make sound.

#+BEGIN_SRC emacs-lisp
(setq ring-bell-function #'ignore)
#+END_SRC

Emacs disables /dangerous/ commands by default in  interactive contexts. I like to live dangerously (with copious use of version control).

#+BEGIN_SRC emacs-lisp
(setq disabled-command-function nil)
#+END_SRC

In general, Emacs should follow symlinks. If it has reason to believe this is a bad idea, it should warn but not halt my workflow.

#+BEGIN_SRC emacs-lisp
(setq vc-follow-symlinks t)
#+END_SRC

Spaces vs tabs is the forever war. I have no stake in this race, except that some environments struggle to correctly display tabs. Fewer struggle with spaces. If this needs to be different for specific major modes, they can override it.

#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil)
#+END_SRC

Recursive minibuffers are often helpful.

#+BEGIN_SRC emacs-lisp
(setq enable-recursive-minibuffers t)
#+END_SRC

*** Desktop

We don't enable =desktop= to handle restoring place after exiting. There are two blocking problems:
1. =desktop= doesn't lead to a consistent restore of all buffers.
2. =desktop= also slows down loading by about 3 seconds, which is unacceptable.

#+BEGIN_SRC emacs-lisp :tangle no
(setq desktop-path (list (=cache-subdirectory "desktop")))
(desktop-save-mode +1)
#+END_SRC

*** Theme

Emacs uses a concept called a =theme= to control system appearance. Each theme applies a layer of =face= description to the loaded buffer. The ordered list of enabled themes is defined in =custom-enabled-themes=.

When I load a theme, I only want that theme to apply. I don't want the previous theme to effect the current experience. To solve this, I define a =load-theme= wrapper called ==load-theme=.

#+BEGIN_SRC emacs-lisp
(defun =load-theme (theme)
  "Load THEME without asking for permission."
  (interactive
   (list (intern (completing-read "Load custom theme: "
                                  (mapcar #'symbol-name
				          (custom-available-themes))
                                  nil t))))
  (load-theme (pcase theme
		('light 'spacemacs-light)
		('dark 'spacemacs-dark)
		(other other))
	      t)
  ;; Disable previous themes
  (mapc #'disable-theme (cdr custom-enabled-themes)))
#+END_SRC

I'm currently using [[https://github.com/nashamri/spacemacs-theme][spacemacs-theme]], both light and dark as my goto-theme.

#+BEGIN_SRC emacs-lisp
;; Currently, running this theme generates warnings.  This fix is:
;; https://github.com/nashamri/spacemacs-theme/pull/200
(elpaca spacemacs-theme
#+END_SRC

Mac has a concept of light and dark mode at the system level. Emacs can be built with hooks to support system appearance change. I want use these hooks when available.

#+BEGIN_SRC emacs-lisp
  (if (boundp 'ns-system-appearance)
      (=add-hook ns-system-appearance-change-functions #'=load-theme)
#+END_SRC

When there isn't any system input for the theme, we will just load the ='light= theme by default.

#+BEGIN_SRC emacs-lisp
    (=load-theme 'light)))
#+END_SRC

*** Cursor

I expect the cursor to be static, and I prefer a bar over a block.

#+BEGIN_SRC emacs-lisp
(setq-default cursor-type 'bar)
(blink-cursor-mode -1)
#+END_SRC

** 1Password

I use 1Password for secrets management. I would like to be able to inject 1Password secrets (like API keys) into my Emacs config from 1Password during startup.

Each call to the 1Password's =op= CLI tool is relatively slow (and requires a authentication step). To avoid making multiple calls, we will model this as a queue and flush system. When a variable is set, we add it to ==1Password--forms=, which acts as our queue. Any time we need prompt access to a variable, we flush the entire queue using =op='s =inject= command, and then =eval-buffer=  the result.

#+BEGIN_SRC emacs-lisp
(defvar =1Password--forms nil
  "A list of forms to evaluate after templating through 1Password.

After forms are evaluated, they are removed from this var.")

(defmacro =1Password-setq (name path &rest consuming-funcs)
  "Declare that NAME should be filled from 1Password.
PATH is the 1Password path to the item.
CONSUMING-FUNCS is a list of functions that are know to consume NAME.

Each consuming func is adviced to ensure that values set with
`=1Password-setq' are actually set before their consuming
functions are run."
  `(progn
     (setq =1Password--forms
           (cons (list 'setq ',name ,(concat "{{ op://Personal/" path " }}"))
                 =1Password--forms))
     ,@(mapcar (lambda (f)
                 `(advice-add ,f :before #'=1Password--ensure))
               consuming-funcs)))

(defun =1Password--flush ()
  "Evaluate `=1Password--forms' after passing it through the 1Password CLI."
  (if-let ((op (executable-find "op")))
      ;; Create a temporary file for `op' to consume. We do this instead of piping into
      ;; `op' directly because `op' (as of April, 2023) doesn't allow itself to be created
      ;; without any stdin or input file. Programmatic consumption in Emacs goes
      ;;
      ;; 1. Create process
      ;; 2. Pipe in input
      ;;
      ;; Unfortunately, `op' errors out between steps (1) and (2) with the error
      ;;
      ;;   [ERROR] 2023/04/09 16:35:12 expected data on stdin but none found
      ;;
      ;; Writing to a file avoid this, at the cost of extra cleanup later. There is a
      ;; minimal security penalty to writing to a temp file, since the file we write only
      ;; contains placeholders for our secret values, not the values themselves.
      (let ((tmp (make-temp-file "1password.template")))
        (with-temp-file tmp
          (insert (mapconcat #'pp-to-string =1Password--forms "\n")))
        (with-current-buffer (process-buffer
                              (make-process :name "1Password Init"
                                            :buffer "1Password"
                                            :command `(,op "inject" "--in-file" ,tmp)
                                            :connecton-type 'pipe
                                            :sentinel #'=1Password--sentinel))
          (set (make-local-variable '=1Password-template-file) tmp)))
    (warn "Could not find 1Password CLI")))

(defun =1Password--sentinel (proc event)
  "The sentinel that controls the 1Password injection process.
PROC is the process and EVENT is the event that triggered the sentinel."
  (when (string-match "finished\n" event)
    ;; According to the manual for `process-exit-status', 256 indicates that a process was
    ;; closed "abnormally". I take this to mean an error was returned.
    (if (eq (process-exit-status proc) 256)
        (warn "1Password did not exit cleanly: %s"
              (let ((b (process-buffer proc)))
                (if (buffer-live-p b)
                    (with-current-buffer b
                      (buffer-substring (point-min) (point-max)))
                  "dead buffer")))
      (let ((b (process-buffer proc)))
        (unless (buffer-live-p b)
          (error "1Password buffer died unexpectedly"))
        ;; Since we know the input file is not being used (because the consuming process
        ;; exited), we can clean up.
        (delete-file (buffer-local-value '=1Password-template-file b))
        ;; We mark ourselves as done, freeing functions like `=1Password--ensure' to exit.
        (setq =1Password--forms nil)
        ;; We then evaluate the buffer. This doesn't present a race condition, since Emacs
        ;; doesn't interrupt running code, even with Sentinels.
        (eval-buffer b)
        (kill-buffer b)))))

(defun =1Password-init-async ()
  "Asyncronously evaluate all declared 1Password variables."
  (=1Password--flush))

(defun =1Password--ensure (&rest args)
  "Syncronously ensure that 1Password has loaded all declared values.
ARGS allows this function to be used in hooks.  ARGS is ignored."
  (ignore args)
  (when =1Password--forms
    (message "Ensuring 1Password variables are loaded")
    (=1Password--flush)
    (while =1Password--forms
      (sit-for 0.05))))
#+END_SRC

If I wanted to load all secrets immediately on startup, I would add in the following. I don't do this because it causes the TouchID™  authentication popup to trigger every time, regardless of if I'm already logged into 1Password on my Mac. This means that opening Emacs in a terminal requires me to authenticate, even if I don't need to use a value derived from 1Password. This is not acceptable.

#+BEGIN_SRC emacs-lisp :tangle no
(add-hook 'elpaca-after-init-hook #'=1Password-init-async)
#+END_SRC

** Modeline

Current customization is basic, and worth revisiting.

I need to know the line and column number.

#+BEGIN_SRC emacs-lisp
(line-number-mode +1)
(column-number-mode +1)
#+END_SRC

** Documentation
*** Introspection
Emacs is famously introspectable. This is facilitated by the =describe-*= functions. The built in introspection is excellent, but it can be improved by showing more information about the values variables hold. The main improvement available is showing the source code where the inspected item is defined. This is what [[https://github.com/Wilfred/helpful][Wilfred/helpful]] does.

#+BEGIN_SRC emacs-lisp
(elpaca helpful
  (global-set-key [remap describe-function] #'helpful-callable)
  (global-set-key [remap describe-key] #'helpful-key)
  (global-set-key [remap describe-variable] #'helpful-variable)
  (global-set-key [remap describe-command] #'helpful-command))
#+END_SRC

Since we are happy with default bindings here, we just remap the existing binding to the =helpful= variant.
*** Eldoc

Emacs includes the excellent [[help:eldoc-mode][eldoc]], which displays information about the object at point in the echo area.

For larger (or more stable) documentation, Eldoc has [[help:eldoc-doc-buffer][eldoc-doc-buffer]], which can hold unabridged documentation.

By default, both the buffer and echo area are used when the buffer is displayed. This is probably a safe default, but it is not ideal. Ideally, the existence of the doc buffer obviates the need for displaying in the echo area.

#+BEGIN_SRC emacs-lisp
;; Don't display in the echo area if the doc buffer is visable
(setq eldoc-echo-area-prefer-doc-buffer t)
#+END_SRC

*** Compilation

Emacs includes a built in mode for compilation output: [[help:compilation-mode][compilation-mode]].

We want it to scroll to the first addressable error.

#+BEGIN_SRC emacs-lisp
(setq compilation-scroll-output 'first-error)
#+END_SRC

** Native compilation

Emacs has support for native compilation of elisp code. This feature leads to a noticeable speedup in performance dependent packages, such as =eglot= and =jsonian=. Emacs compiles elisp code asynchronous in the background when a package is loaded.

We don't want to see compilation errors pop up for existing packages we have, since they are generally not actionable. We instead shunt them into the =*Warnings*= buffer.

#+BEGIN_SRC emacs-lisp
(setq native-comp-async-report-warnings-errors 'silent)
#+END_SRC

** Movement

Emacs defines a multitude of ways to navigate around, but I often find it lacking in certain respects.

*** TODO Windows

*** Jump to character

One thing I miss from =vim= is the ability to easily jump between and around characters. I have written a small package to accomplish this, called /GoTo Quickly/, and I load that now.

#+BEGIN_SRC emacs-lisp
(load (expand-file-name "gtq.el" user-emacs-directory))
#+END_SRC

It defines =gtq-goto=, which brings up a model interface for quickly navigating among characters.

#+BEGIN_SRC  emacs-lisp
(global-set-key (kbd "C-'") #'gtq-goto)
#+END_SRC

If the package proves useful, I will expand it and probably add more bindings, but right not it's pretty simple.

** Whitespace

Trailing whitespace is generally wrong. However, I need to be careful that I don't have lots of whitespace diffs on shared files. =ws-butler= handles this nicely.

Since the package is unmaintained, I use hlissner's (of Doom Emacs fame) fork, on the grounds that since it is used by a popular distribution, it will probably work.

#+BEGIN_SRC emacs-lisp
(elpaca (ws-butler :host github :repo "hlissner/ws-butler")
#+END_SRC

It is enabled everywhere.

#+BEGIN_SRC emacs-lisp
  (ws-butler-global-mode))
#+END_SRC

I use =fill-paragraph= often. It defaults to /70/ characters, which is too conservative for me.

#+BEGIN_SRC emacs-lisp
(setq-default fill-column 90)
#+END_SRC

** Session persistence & Backups

By default, Emacs scatters backup and auto-save files over the directory in use, but does not remember useful information such as where I was last I edited the buffer. This needs to be fixed.

=save-place-mode= is a built-in global minor mode to save the position of point in a buffer, and to persist that between sessions. It does that by writing each buffer position to a file, and then referring to the file when a buffer is revisited. This is fine, but we want to redirect the file to our cache.

#+BEGIN_SRC emacs-lisp
(setq save-place-file (=cache-file "places"))
(save-place-mode +1)
#+END_SRC

I move all auto-saves into a centralized directory that I know is /not/ under source control.

#+BEGIN_SRC emacs-lisp
(setq auto-save-list-file-prefix
      (concat (=cache-subdirectory "auto-save-list") ".saves-"))
#+END_SRC

Similarly, I move all backups to a cache directory.

The ="."= means that this is the backup location for files in all directories.

#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist `(("." . ,(=cache-subdirectory "backup"))))
#+END_SRC

** Project Management

As far as I know, Emacs has two project management solutions: [[https://github.com/bbatsov/projectile][projectile]] and [[https://github.com/emacs-mirror/emacs/blob/master/lisp/progmodes/project.el][project.el]]. Because =project.el= is in-trunk, I have decided to use it. It works out of the box, but I still needed a couple of tweaks.

=project.el= caches which projects have been accessed, which needed to be re-mapped into the cache directory.

#+BEGIN_SRC emacs-lisp
(setq project-list-file (=cache-file "projects"))
#+END_SRC

When a project is entered, =project-switch-commands= is used to determine what dialog is displayed to the user.

Before a switch command is executed, I set =default-directory= to the project I just switched to. This enables commands like =magit= and =vterm= to kick off in the new project.

#+BEGIN_SRC emacs-lisp
(defun =project-set-switch-commands (pallet unbound)
  "Set `project-switch-commands'.

This function alters the commands passed in via PALLET to make
them aware of the new project."
  (setq project-switch-commands
        (append
	 (mapcar
	  (lambda (x) (cons
		       (lambda ()
			 (interactive)
			 (let ((default-directory
			        (or project-current-directory-override
				    default-directory)))
			   (funcall-interactively (car x))))
		       (cdr x)))
	  pallet)
         unbound)))
#+END_SRC

This function goes to the most recently used buffer in the project.

#+BEGIN_SRC emacs-lisp
(defun =project-switch-to-most-recent ()
  "Switch to the most recently used buffer in a project."
  (interactive)
  (if-let* ((proj (project-current nil project-current-directory-override))
            (bufs (seq-filter
                   (lambda (b) (and (not (eq b (current-buffer)))
                                    (not (string-prefix-p " " (buffer-name b)))))
                   (project-buffers proj))))
      (switch-to-buffer (car bufs))
    (message "Could not find any buffers to switch to in '%s'"
             project-current-directory-override)
    (sit-for 1)
    (project-switch-project project-current-directory-override)))
#+END_SRC

We now define the actual command pallet we want.

#+BEGIN_SRC emacs-lisp
(=project-set-switch-commands
 '((project-find-file "Find file" "f")
   (consult-find "`find` file" "C-f")
   (consult-ripgrep "Find regexp" "g")
   (magit "Git" "v")
   (=project-vterm "Shell" "t"))
 '((=project-switch-to-most-recent "Most recent" "r")))
#+END_SRC

To avoid duplicating commands in the project map, we provide a mapping for quick access to the project switcher against the current project.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x P") (lambda () (interactive)
                                "Run the project switcher in the current project"
                                (project-switch-project (when-let ((p (project-current)))
                                                          (project-root p)))))
#+END_SRC

** Completion

A lot of Emacs customization goes into Emacs, which impressively does nothing out of the box.

#+BEGIN_SRC emacs-lisp
(setq savehist-file (=cache-file "savehist"))
(savehist-mode +1)
#+END_SRC

*** Completion at point

For completion at point, there are two main options: [[https://github.com/minad/corfu][corfu]] and [[https://company-mode.github.io][company]]. =company= is by far the 800 pound gorilla in this fight with a large number of custom backends.  I have decided to use =corfu= instead, since it integrates with Emacs's existing =completion-at-point-functions=.

#+BEGIN_SRC emacs-lisp
(elpaca corfu
#+END_SRC

I prefer aggressive completion.

#+BEGIN_SRC emacs-lisp
(setq corfu-auto t          ;; Complete when available
      corfu-auto-delay 0    ;; Without any delay
      corfu-auto-prefix 1)  ;; Wait only for the first character
#+END_SRC

I want completion to be enabled everywhere.

#+BEGIN_SRC emacs-lisp
(global-corfu-mode)
#+END_SRC

Finally, I want completion to not interfere with my normal typing. By default, return finalizes a completion. I find this super disruptive, since I often want to type =RET=, even when a completion is prompted. The solution is to unbind =RET= and rebind a less intrusive option. I use control-space.

This unbinds ="RET"= in the map =corfu= uses during completion. The trailing =t= ensures that we are removing this binding, not just setting it to =nil=. This allows fallback to other keymaps (such as the =self-insert-command= in the =global-mode-map=).

#+BEGIN_SRC emacs-lisp
(define-key corfu-map (kbd "RET") nil t)
#+END_SRC

I then apply the correct bindings for Ctrl-Space. Unfortunately, there doesn't seem to be a binding that applies to both the terminal and the GUI, so I apply a separate binding for both.

#+BEGIN_SRC emacs-lisp
(dolist (spc '("C-@" "C-SPC"))
  ;; C-@ works in the terminal, but not in GUI.
  ;; C-SPC works in GUI, but not in the terminal.
  (define-key corfu-map (kbd spc) #'corfu-insert)))
#+END_SRC

=corfu= only works on a GUI. When I don't have access to a GUI, I load [[https://codeberg.org/akib/emacs-corfu-terminal][corfu-terminal]] to get the graphics to stay consistent.

#+BEGIN_SRC emacs-lisp
(unless (display-graphic-p)
  ;; Since we don't need the additional mode on GUI, only download it
  ;; when on a TTY.
  (elpaca (corfu-terminal
	   :type git
	   :repo "https://codeberg.org/akib/emacs-corfu-terminal.git")
    (corfu-terminal-mode +1)))
#+END_SRC

*** TODO Minibuffer completion

#+BEGIN_SRC emacs-lisp
;; A vertical completion framework, applying a nicer UX to default
;; compleating-read style completion.
(elpaca vertico
  (setq vertico-cycle t)
  (vertico-mode))

;; Helpful information in the margin of `vertico' completions.
(elpaca marginalia (marginalia-mode))

(elpaca orderless
  (setq completion-styles '(orderless basic)
	completion-category-overrides '((file (styles basic partial-completion)))))
#+END_SRC

*** Enhanced consulting completion

[[https://github.com/minad/consult][consult]] is a utility package that provides a boat load of /improved/ consulting commands. I rebind several existing built-in commands with their =consult= equivalent.

#+BEGIN_SRC emacs-lisp
(elpaca consult
  (global-set-key [remap goto-line] #'consult-goto-line)
  (global-set-key [remap Info-search] #'consult-info)
  (global-set-key [remap yank-pop] #'consult-yank-pop)
  (global-set-key [remap imenu] #'consult-imenu)

  ;; By default, consult applies the prefix ?# to all registers, which
  ;; is not necessary.
  (setq consult-register-prefix nil)

  (global-set-key [remap jump-to-register] #'consult-register-load)
  (global-set-key [remap switch-to-buffer] #'consult-buffer)
  (global-set-key [remap switch-to-buffer-other-frame] #'consult-buffer-other-frame)
  (global-set-key [remap switch-to-buffer-other-window] #'consult-buffer-other-window)
  (define-key isearch-mode-map [remap isearch-edit-string] #'consult-isearch-history))
#+END_SRC

** Major Modes

Emacs defines the general behavior of each buffer with a =major-mode= (stored in a variable of the same name). In general, each language defines a major mode, as well as Emacs specific interaction environments like =dired= and =magit=. Major modes support inheritance, with all modes derived from =fundamental-mode=.

*** Text Mode

Text mode is the parent mode for unstructured text.

We want spelling support for text all text modes, so we turn on =flyspell-mode= for =text-mode=. This applies for all derived modes as well.

#+BEGIN_SRC emacs-lisp
(=add-hook 'text-mode-hook
  #'flyspell-mode
  #'visual-line-mode)
#+END_SRC

*** Programming Mode

=prog-mode= is for writing structured text for a computer to read (programs). All programming language major modes and most data format major modes are ultimately derived from =prog-mode=.

For programming, we want spellcheck for strings and comments, but not necessarily for all text (such as variable names). Flyspell provides =flyspell-prog-mode= for this purpose.

#+BEGIN_SRC emacs-lisp
(=add-hook prog-mode-hook #'flyspell-prog-mode)
#+END_SRC

Programming languages introduce a new type of error: syntax errors. This is handled by =flymake=, which we enable for all programming languages.

#+BEGIN_SRC emacs-lisp
(=add-hook prog-mode-hook #'flymake-mode)
#+END_SRC

**** Tree Sitter

Emacs 29 includes built-in support for [[https://tree-sitter.github.io/tree-sitter/][tree-sitter]], under the =treesit= prefix. Paradoxically, they enable some tree sitter modes by default, but don't bundle the appropriate grammars into Emacs. This means that an unconfigured Emacs errors when opening a =.ts= file.

=emacs -Q bad-decision.ts=  fails with

#+BEGIN_QUOTE
 ■  Warning (treesit): Cannot activate tree-sitter, because language definition\
 for typescript is unavailable (not-found): (libtree-sitter-typescript.so libtr\
ee-sitter-typescript.dylib) No such file or directory
#+END_QUOTE

We need to define the set of valid language grammars.

#+BEGIN_SRC emacs-lisp
(setq treesit-language-source-alist
      '((typescript . ("https://github.com/tree-sitter/tree-sitter-typescript" "master" "typescript/src"))
	(tsx        . ("https://github.com/tree-sitter/tree-sitter-typescript" "master" "tsx/src"))
        (json       . ("https://github.com/tree-sitter/tree-sitter-json"       "master" "src"))))
#+END_SRC

By default, =treesit= installs grammars in =(expand-file-name "tree-sitter" user-emacs-directory)=. We want to redirect this to a directory in =.cache=.

#+BEGIN_SRC emacs-lisp
(defvar =treesit-language-cache (=cache-subdirectory "tree-sitter")
  "The directory to cache compiled tree-sitter language files.")

(add-to-list 'treesit-extra-load-path =treesit-language-cache)

(advice-add #'treesit--install-language-grammar-1 :around
	    (lambda (fn out-dir &rest args)
	      (apply fn (or out-dir =treesit-language-cache) args)))
#+END_SRC

**** LSP

Many major modes augment their functionality with a [[https://microsoft.github.io/language-server-protocol/][LSP Server]] (Language Server Protocol... Server). [[help:eglot][eglot]] is a built in LSP consumer for Emacs. It doesn't require much setup.

=eglot-ensure= needs to be called via each  =major-mode='s =hook=. Because of the blocking nature of =eglot-ensure=, we provide wrapper function that will allow the buffer to display before enabling the LSP server.

#+BEGIN_SRC emacs-lisp
(defun =lsp-ensure ()
  "Turn on the mode appropriate LSP mode."
  (run-with-idle-timer 0 nil #'eglot-ensure))
#+END_SRC

*** Emacs Lisp

=emacs-lisp-mode= is the major mode used when editing Emacs lisp. Emacs is already pretty good at editing lisps (kind of it's thing). It is pretty stingy on syntax highlighting though, which is especially painful for a heavily dynamic language. I use [[https://github.com/Fanael/highlight-defined][highlight-defined]] to highlight symbols that are known to be defined in the current session.

By default, =highlight-defined= uses its own set of faces. I don't want to spend the effort to maintain a custom set of faces. Setting =highligh-defined-face-use-itself= restores the default faces. This effectively sets =highlight-defined-${KIND}-name-face= to =font-lock-${KIND}-name-face=.

#+BEGIN_SRC emacs-lisp
(elpaca highlight-defined
  (setq highlight-defined-face-use-itself t) ;; Use standard faces when highlighting.
  (=add-hook emacs-lisp-mode-hook #'highlight-defined-mode))
#+END_SRC

*** JSON

I maintain my own major mode for json: =jsonian=. It has some cool features, but the major win is working well in large buffers.

To avoid recomputing strings vs keys, =jsonian= can use existing syntax highlighting as pre-computed indexes. Unfortunately, the Emacs 29 version bump changed how =font-lock= applied, and broke this optimization. I disable it on newer Emacs versions.

#+BEGIN_SRC emacs-lisp
(elpaca jsonian
  (setq jsonian-ignore-font-lock (>= emacs-major-version 29)))
#+END_SRC

*** Git

[[https://magit.vc][Magit]] is everyone's favorite git client, and I'm no exception.

#+BEGIN_SRC emacs-lisp
(elpaca magit
  (defun =magit-patch-yank (&optional arg)
    "Like `magit-patch-save' except the patched is copied to the kill ring
instead of a file. ARG is passed directly to
 `magit-patch-save'."
    (interactive '(current-prefix-arg))
    (require 'magit-patch)
    (let ((fname (expand-file-name (make-temp-name "my-magit")
                                   (or small-temporary-file-directory
                                       temporary-file-directory))))
      (magit-patch-save fname arg)
      (with-temp-buffer
        (insert-file-contents-literally fname)
        (delete-file fname)
        (kill-new
         (buffer-substring (point-min) (point-max))))))

  (with-eval-after-load 'magit
    (setq magit-display-buffer-function
          #'magit-display-buffer-same-window-except-diff-v1))

  (with-eval-after-load 'magit-patch
    (require 'magit-patch)
    (transient-append-suffix 'magit-patch "r"
      '("y" "Yank diff as patch" =magit-patch-yank))))
#+END_SRC

I often share code snippets from GitHub repos. It is helpful to be able to link to snippets without going to [[https://github.com][github.com]], and GitHub maintains a stable and easily compute-able link format.

GitHub formats repo links like so:

#+BEGIN_SRC
github.com/${ORG}/${REPO}/blob/${COMMIT-SHA}/${FILE_PATH}#L${LINE_START}[-L${LINE_END}]
#+END_SRC

We can quickly and easily retrieve this information. The =(interactive "r")= tells Emacs that this function should accept the current region when called interactively. We save the generated URL into the =kill-ring=, and print it to the screen.

#+BEGIN_SRC emacs-lisp
(defun =github-code-region (start end)
  "Copy the GitHub permalink of the highlighted region into the `kill-ring'.
Operate on the region defined by START to END."
  (interactive "r")
  (let ((line-start (line-number-at-pos start t))
        (line-end (line-number-at-pos end t))
        (commit (magit-git-string "rev-parse" "--verify" "HEAD"))
        (path (magit-current-file))
        (url (car-safe (magit-config-get-from-cached-list "remote.origin.url"))))
    (unless url
      (user-error "Could not get remote URL"))
    (kill-new
     (format "%s/blob/%s/%s#L%d%s"
             (string-trim-right url (regexp-quote ".git")) commit path line-start
             (if (= line-start line-end)
                 ""
	       (format "-L%d" line-end))))
    (message "Github link to region: %s" (car kill-ring))))
#+END_SRC

**** Transient

Magit handles it's lovely UX with a subsidiary package: [[https://github.com/magit/transient][transient]], which caches its history locally. We need to remap this into =.cache= to keep =.emacs.d= clean. We don't need to =require= transient ourselves, since Magit depends on it.

#+BEGIN_SRC emacs-lisp
;; Transient does not define it's own history dir, so we do it ourselves.
(defvar =transient-cache-dir (=cache-subdirectory "transient")
  "The directory where transient history files are stored.")
(setq
 transient-history-file (expand-file-name "history.el" =transient-cache-dir)
 transient-values-file (expand-file-name "values.el" =transient-cache-dir)
 transient-levels-file (expand-file-name "levels.el" =transient-cache-dir))
#+END_SRC

*** Org Mode

[[https://orgmode.org][org-mode]] is a staple of Emacs, providing a todo list, calendar, literate programming environment and much more. =org-mode= comes built-in to Emacs, but I think it's worth opting into a more developed version.

#+BEGIN_SRC emacs-lisp
(elpaca org)
#+END_SRC

=org-mode= is structured around putting all your =.org= files into a single directory. It isn't required, but I generally do it anyway. The default value is =~/org=, but I prefer =~/Documents/org=, since it is synced by iCloud. This makes my =.org= files accessible on my iPhone and iPad.

#+BEGIN_SRC emacs-lisp
(setq org-directory "~/Documents/org"
      org-id-locations-file (=cache-file "id-locations" "org"))
#+END_SRC

**** Readability

=org-mode= is primarily used for reading, so it's worth making it look as nice as possible.

I hide markup text such as =*=, =/= and ===.

#+BEGIN_SRC emacs-lisp
(setq org-hide-emphasis-markers t)
#+END_SRC

Similarly, we can render pretty equations like =(\alpha - \beta) \div \Omega=.

#+BEGIN_SRC emacs-lisp
(setq org-pretty-entities t)
#+END_SRC

We would prefer that org renders headings as =✿ Foo= then =***✿ Foo=.

#+BEGIN_SRC emacs-lisp
(setq org-hide-leading-stars t)
#+END_SRC

I replace stand org bullets with graphical overlays.

#+BEGIN_SRC emacs-lisp
(elpaca org-bullets (=add-hook org-mode-hook #'org-bullets-mode))
#+END_SRC

I would prefer that org is read with variable width text, but I need source blocks and tables to be rendered with fixed width text. This can be accomplished by overriding org text properties.

This solution was inspired by [[https://zzamboni.org/post/beautifying-org-mode-in-emacs/][zzamboni]].

#+BEGIN_SRC emacs-lisp
(custom-theme-set-faces
 'user
 '(variable-pitch ((t (:family "Helvetica"))))
 '(fixed-pitch ((t ( :family "Fira Code Retina"))))
 '(org-block ((t (:inherit fixed-pitch))))
 '(org-code ((t (:inherit (shadow fixed-pitch)))))
 '(org-document-info ((t (:foreground "dark orange"))))
 '(org-document-info-keyword ((t (:inherit (shadow fixed-pitch)))))
 '(org-indent ((t (:inherit (org-hide fixed-pitch)))))
 '(org-link ((t (:foreground "royal blue" :underline t))))
 '(org-meta-line ((t (:inherit (font-lock-comment-face fixed-pitch)))))
 '(org-property-value ((t (:inherit fixed-pitch))) t)
 '(org-special-keyword ((t (:inherit (font-lock-comment-face fixed-pitch)))))
 '(org-table ((t (:inherit fixed-pitch :foreground "#83a598"))))
 '(org-tag ((t (:inherit (shadow fixed-pitch) :weight bold :height 0.8))))
 '(org-verbatim ((t (:inherit (shadow fixed-pitch))))))
#+END_SRC

I can now safely enable variable pitch mode.

#+BEGIN_SRC emacs-lisp
(=add-hook org-mode-hook #'variable-pitch-mode)
#+END_SRC

**** Org as a ToDo App

=org-mode= defines a =TODO= item as any header that begins with a todo /keyword/.  The keywords are defines as so.

#+BEGIN_SRC emacs-lisp
(setq org-todo-keywords
      '((sequence "TODO(t)" "WAIT(w)" "DONE(d)")
	(type "PROJ(p)")
	(type "KILL(k)")
	(type "LOOP(l)")))
#+END_SRC

I want to leave a small note every time a =TODO= changes state.

#+BEGIN_SRC emacs-lisp
(setq org-log-done 'note)
#+END_SRC

TODO: Adjust how [[help:org-refile][org-refile]] works to allow refiling into the hierarchy local buffer hierarchy.

#+BEGIN_SRC emacs-lisp
(setq org-refile-use-outline-path t
      org-outline-path-complete-in-steps nil)
#+END_SRC

**** Org Agenda

=org-agenda= is a component of =org-mode= that displays =TODO= elements as part of a time view.

I scatter =TODO= elements all over my org files, so I need to tell =org-mode= which directories it should search through.

#+BEGIN_SRC emacs-lisp
(setq org-agenda-files (list org-directory))
#+END_SRC

I generally use it to discover what I need to do this week, so I tell it to work in increments of a week.

#+BEGIN_SRC emacs-lisp
(setq org-agenda-span 'week)
#+END_SRC

**** Source Blocks

Org allows embedded source blocks, framed by =#+BEGIN_SRC= and =#+END_SRC=.

By default, they are indented, but this is confusing since it doesn't match other text (which is not). I disable source indentation:

#+BEGIN_SRC emacs-lisp
(setq org-src-preserve-indentation t)
#+END_SRC

When calling [[help:org-edit-special][org-edit-special]], Emacs defaults to putting the buffer in another frame. Generally, we want the same frame.

#+BEGIN_SRC emacs-lisp
(setq org-src-window-setup 'current-window)
#+END_SRC

**** Org Roam

Org-roam is a [[https://en.wikipedia.org/wiki/Zettelkasten][zettelkasten]] based notes system. It is an extension to =org-mode=.

#+BEGIN_SRC emacs-lisp
(elpaca org-roam
  (setq org-roam-directory (expand-file-name "roam" org-directory)
	org-roam-db-location (=cache-file "roam.db" "org"))
  ;; `org-roam-node-list' is called before a list of nodes is displayed to the user. We
  ;; use it as a prompt to turn on database syncing without slowing down startup.
  (advice-add #'org-roam-node-list :before (lambda (&rest _) (org-roam-db-autosync-mode +1))))
#+END_SRC

**** Utilities

This is a utility function to resolve GH links to their issue name.

TODO Combine ==org-describe-link= with =org-link-make-description-function= to get the desired behavior by default.

#+BEGIN_SRC emacs-lisp
(defun =org-describe-link ()
  "Heuristically add a description to the `org-mode' link at point."
  (interactive)
  (when-let* ((ctx (org-element-context))
              (type (org-element-type ctx))
	      (link (org-element-property :raw-link ctx))
	      (description (pcase link
			     ;; This is an https: link to a github issue, so we can use
			     ;; `gh` to get the issue title and display that as the
			     ;; description.
			     ((pred (string-match
				     "https://github.com/\\([-a-zA-Z0-9]+\\)/\\([-a-zA-Z0-9]+\\)/\\(pull\\|issues\\)/\\([0-9]+\\)"))
			      (with-temp-buffer
				(unless (equal 0
					       (call-process
						(executable-find "gh") nil t nil
						"issue" "view" (substring link (match-beginning 4) (match-end 4))
						(concat "--repo="
							(substring link (match-beginning 1) (match-end 1))
							"/"
							(substring link (match-beginning 2) (match-end 2)))
						"--json=title"))
				  (user-error "Failed to get title from GH"))
				(goto-char (point-min))
				(alist-get 'title (json-parse-buffer :object-type 'alist))))
			     ;; Unable to describe link, so let the user do it
			     (_
			      (message "No option matched to describe the link at point: %s" link)
			      nil))))
    (save-excursion
      (delete-region (org-element-property :begin ctx)
		     (org-element-property :end ctx))
      (org-insert-link link link description))))
#+END_SRC

*** Terminal

There are quite a few different terminal emulators for Emacs, from the built in =term= to the fully Emacs Lisp based shell =eshell=. I prefer [[https://github.com/akermu/emacs-libvterm][vterm]], an Emacs integration of the [[https://launchpad.net/libvterm][libvterm]] C99 library. It acts as a fully function unconstrained terminal, just like =Termnial.app= or [[https://github.com/alacritty/alacritty][Alacritty]].

#+BEGIN_SRC emacs-lisp
(elpaca vterm
  (setq vterm-max-scrollback 10000))
#+END_SRC

=vterm= isn't project aware, but I would prefer that it was. This can be accomplished by advising the =vterm= function.

#+BEGIN_SRC emacs-lisp
(defun =project-vterm (&optional arg)
  "A project aware invocation of `vterm'.
ARG is passed to `vterm' without processing."
  (interactive)
  (defvar vterm-buffer-name)
  (if-let ((project (project-current)))
      (let ((default-directory (project-root project))
	    (vterm-buffer-name (concat "*vterm<" (project-name project) ">*")))
	(vterm arg))
    (vterm arg)))

(require 'project)
(defalias 'project-shell '=project-vterm)
#+END_SRC

We ensure that =vterm= buffers are cleaned up when they are a part of a project by adding them to =project-kill-buffers=.

#+BEGIN_SRC emacs-lisp
(add-to-list 'project-kill-buffer-conditions
	     '(and
	       (derived-mode . vterm-mode)
	       "^\\*vterm<.*>\\*$"))
#+END_SRC

It is possible to integrate Emacs's =default-directory= with =vterm=, but it requires shell side support. Specifically, the running shell needs to =source= a file that =vterm= includes. We make this easier by projecting that file into =vterm='s environment.

#+BEGIN_SRC emacs-lisp
(setq vterm-environment
      (list (concat "VTERM_DATA="
		    (expand-file-name "repos/emacs-libvterm/etc/emacs-vterm-zsh.sh"
				      elpaca-directory))))
#+END_SRC

I then utilize this variable in my =.zshrc= file:

#+BEGIN_SRC zsh
if [[ "$INSIDE_EMACS" = vterm ]]; then
    src="$VTERM_DATA"
    if [[ -f "$src" ]]; then
        source "$src"
    else
        echo "Could not find vterm fish file to source: $src"
    fi
fi
#+END_SRC

*** Go

I need a major mode: =go-mode=.

#+BEGIN_SRC emacs-lisp
(elpaca go-mode)
#+END_SRC

 I hook up =eglot= for serving =lsp= and a format on save hook.

#+BEGIN_SRC emacs-lisp
(=add-hook go-mode-hook
  #'=lsp-ensure
  (lambda () (add-hook 'before-save-hook #'gofmt-before-save nil t)))
#+END_SRC

*** Markdown

=markdown-mode= provides Markdown support.

#+BEGIN_SRC emacs-lisp
(elpaca markdown-mode
#+END_SRC

This snippet automatically activates =markdown-mode= for files ending in =.markdown=, =.md=.

#+BEGIN_SRC emacs-lisp
  (autoload 'markdown-mode "markdown-mode"
    "Major mode for editing Markdown files" t)
  (add-to-list 'auto-mode-alist '("\\.markdown\\'" . markdown-mode))
  (add-to-list 'auto-mode-alist '("\\.md\\'" . markdown-mode))
#+END_SRC

Because GitHub is so dominant, I assume that any =README.md= is going in GitHub, and use GitHub Flavored Markdown (GFM). I'm not sure if I intend to keep this snippet, but it was recommended by =markdown-mode='s website.

#+BEGIN_SRC emacs-lisp
  (autoload 'gfm-mode "markdown-mode"
    "Major mode for GitHub Flavored Markdown files" t)
  (add-to-list 'auto-mode-alist '("README\\.md\\'" . gfm-mode)))
#+END_SRC

*** YAML

#+BEGIN_SRC emacs-lisp
(elpaca yaml-mode)
#+END_SRC

*** Shell

Emacs comes with a built-in mode for shell scrips: [[help:sh-mode][sh-mode]].

When =sh-mode= is setup, [[help:sh-set-shell][sh-set-shell]] is called as part of determining which shell kind =sh-mode= is serving. Unfortunately, it prints a success message to the buffer. This pollutes the echo area when [[help:org-babel-tangle][org-babel-tangle]] is called.

#+BEGIN_SRC emacs-lisp
(advice-add #'sh-set-shell :before-while
	    (lambda (format-string &rest args)
	      "Silence \"Setting up ...\" and \"Indentation setup for ...\" messages."
	      (or
	       (string= "Setting up indent for shell type %s" format-string)
	       (string= "Indentation setup for shell type %s" format-string))))
#+END_SRC

*** TypeScript

Emacs 29 has built in support for typescript syntax highlighting with [[help:typescript-ts-mode][typescript-ts-mode]].

As of Emacs =30.0.50=, =typescript-ts-mode.el= contains this line:

#+BEGIN_SRC emacs-lisp
(require 'treesit)
(if (treesit-ready-p 'typescript)
    (add-to-list 'auto-mode-alist '("\\.ts\\'" . typescript-ts-mode)))
#+END_SRC

Unfortunately, it does not work in =typescript-ts-mode.el= because the check is not auto-loaded, so its not loaded until after a function from [[help:featurep][feature]] =typescript-ts-mode= is loaded. By including the above directly in our init file, we get the desired behavior.

For completion and semantic analysis, we use LSP:

#+BEGIN_SRC emacs-lisp
(=add-hook 'typescript-ts-mode-hook #'=lsp-ensure)
#+END_SRC

*** Rust

Rust is pretty simple, we want =rust-mode= and then a LSP on top:

#+BEGIN_SRC emacs-lisp
(elpaca rust-mode
  (setq rust-format-on-save t))
(=add-hook rust-mode-hook #'lsp-ensure)
#+END_SRC

*** ChatGPT

I have written a package for interacting with =ChatGPT= called [[https://github.com/iwahbe/chat.el][chat.el]]. This provides basic functionality to interact with [[https://openai.com][OpenAI]]'s [[https://platform.openai.com/docs/api-reference/chat][API]].

#+BEGIN_SRC emacs-lisp
(elpaca (chat.el :host github :repo "iwahbe/chat.el")
  (=1Password-setq chat-api-key "OpenAI/API Keys/Personal" #'chat-get-api-key))
#+END_SRC

** Pulumi

I currently work for [[https://www.pulumi.com][Pulumi]], and I define a set of special functions to work specifically with Pulumi specific data formats.

The largest in terms of scope (but not code) is a special mode for Pulumi YAML:

#+BEGIN_SRC emacs-lisp
(elpaca (pulumi-yaml :host github :repo "pulumi/pulumi-lsp"
                     :files ("editors/emacs/*"))
  (require 'pulumi-yaml)
  (=add-hook pulumi-yaml-mode-hook #'=lsp-ensure))
#+END_SRC

Pulumi defines its providers with a [[https://www.pulumi.com/docs/guides/pulumi-packages/schema/][schema]]. This function follows internal schema links by leveraging  [[JSON][jsonian]].

#+BEGIN_SRC emacs-lisp
(defun =pulumi-follow-schema-link ()
  "Follow a link in the pulumi schema."
  (interactive)
  (unless (derived-mode-p 'jsonian-mode)
    (user-error "Requires `jsonian-mode'"))
  (if-let* ((pos (jsonian--string-at-pos))
            (s (buffer-substring-no-properties (1+ (car pos)) (1- (cdr pos))))
            (seperator (string-search "/" s 3))
            (path (concat "[\"" (substring s 2 seperator) "\"]" "[\"" (substring s (1+ seperator)) "\"]")))
      (jsonian-find path)
    (user-error "Something went wrong")))
#+END_SRC

Pulumi has repos, so many repos. Often, working on a bug in one repository requires linking in several others. These functions make adding go module [[https://go.dev/ref/mod#go-mod-file-replace][replace]] directives to other Pulumi repositories easy.

#+BEGIN_SRC emacs-lisp
(defun =pulumi-go-src-root ()
  "The root of the pulumi go src."
  (expand-file-name
   "src/github.com/pulumi"
   (or
    (getenv "GOPATH")
    (expand-file-name
     "go"
     (expand-file-name
      user-login-name
      "/Users" )))))

(defun =pulumi-go-projects ()
  "A list of go project paths under the pulumi org."
  (seq-map #'car
           (seq-filter (lambda (attr)
                         (and
                          (cadr attr) ;; A directory
                          (not (member (car attr) '("." ".." "templates")))))
                       (directory-files-and-attributes (=pulumi-go-src-root)))))

(defun =pulumi-go-modules (dir depth)
  "A list of go paths contained in the directory.
DEPTH specifies how many levels to search through."
  (when (and dir (>= depth 1) (file-directory-p dir))
    (let ((root (expand-file-name "go.mod" dir)))
      (if (file-exists-p root)
          (with-temp-buffer
            (insert-file-contents-literally root)
            (search-forward-regexp "^module \\(.+\\)$")
            (list
             dir
             (buffer-substring
              (match-beginning 1)
              (match-end 1))))
        (flatten-list
         (seq-filter #'identity
                     (seq-map
                      (lambda (x) (=pulumi-go-modules (expand-file-name x dir) (1- depth)))
                      (seq-filter (lambda (x) (not (member x '("." ".."))))
                                  (directory-files dir)))))))))

(defun =pulumi-module-path-map ()
  (let ((m (make-hash-table :test #'equal))
        (root (=pulumi-go-src-root)))
    (mapc
     (lambda (dir)
       (let* ((p (expand-file-name dir root))
             (path-and-mods (=pulumi-go-modules p 2)))
         (while path-and-mods
           (puthash (cadr path-and-mods) (car path-and-mods) m)
           (setq path-and-mods (cddr path-and-mods)))))
     (=pulumi-go-projects))
    m))

(defun =pulumi-replace (&optional arg)
  "Insert the appropriate `replace` directive for a pulumi project."
  (interactive
   (list (completing-read "Select replace target: "
                          (=pulumi-module-path-map)
                          nil t)))
  (insert "replace " arg " => "
          (file-relative-name
           (gethash arg (=pulumi-module-path-map)))
          "\n"))
#+END_SRC

** Custom framework

In general, we want all customizations to occur in =init.org=. Since there is no obvious way to non-destructively disable =custom=, we set it to use an external file: =custom.el=.

#+BEGIN_SRC emacs-lisp
(setq custom-file (expand-file-name "custom.el" user-emacs-directory))
#+END_SRC

Customizations aren't loaded by default, so we also need to instruct Emacs to load =custom.el= if it exists.

#+BEGIN_SRC emacs-lisp
(when (file-exists-p custom-file)
  (load custom-file))
#+END_SRC

* Zsh

=zsh= has multiple startup files. According to [[https://zsh.sourceforge.io/Intro/intro_3.html][the documentation]], the load order goes like this

|--------------------+----------------------------|
| Name               | Condition                  |
|--------------------+----------------------------|
| $ZDOTDIR/.zshenv   | Always                     |
| $ZDOTDIR/.zprofile | Login shells only          |
| $ZDOTDIR/.zshrc    | Interactive shells only    |
| $ZDOTDIR/.zlogin   | Login shells only          |
| $ZDOTDIR/.zlogout  | Login shells only, on exit |
|--------------------+----------------------------|

** Literate Configuration

Emacs has [[help:sh-mode][sh-mode]], but no =zsh-mode=. Unfortunately, =org-mode= expects a mode called =zsh-mode= when activating [[help:org-edit-special][org-edit-special]]. Since the built-in =zsh-mode= can handle =.zsh= files just fine, we fake it.

#+BEGIN_SRC emacs-lisp
(defalias 'zsh-mode 'sh-mode)
#+END_SRC

** =$PATH= and the Environment

We want to set =$PATH= in =.zshenv=, and set aliases in =.zshrc=.

=zsh= has a utility to declare a variable as a list of unique values. This describes =$PATH= perfectly.

#+BEGIN_SRC zsh :tangle .zshenv
typeset -U path
#+END_SRC

We now want to set the path to interact with various programs we have installed. To keep the =.zshenv= file clean, we only want to set the path when the associated files exist. For clarity, we define two simple helper functions:

#+BEGIN_SRC zsh :tangle .zshenv
# exa_exists <executable>
function exe_exists {
    type "$1" > /dev/null;
    return $?;
}

# add_to_path <path>
function add_to_path {
    path=("$1" "$path[@]")
}
#+END_SRC

We can now use those to set up the path.

For some reason, when =.zshenv= is run, =/usr/local/bin= is not present on the path.

#+BEGIN_SRC zsh :tangle .zshenv
if [[ -d "/usr/local/bin" ]]; then
   add_to_path "/usr/local/bin"
fi
#+END_SRC

#+BEGIN_SRC zsh :tangle .zshenv
if [[ -f "$HOME/.cargo/env" ]]; then
   source "$HOME/.cargo/env"
fi

if exe_exists go; then
   export GOPATH="$HOME/go"
   export GOBIN="$GOPATH/bin"
   add_to_path "$GOBIN"
fi

if exe_exists dotnet; then
   add_to_path "$HOME/.dotnet/tools"
fi

export EDITOR='emacs -nw'
#+END_SRC

** Aliases

#+BEGIN_SRC zsh
alias aws-login='aws sso login --profile=dev-sandbox && eval $(aws-sso-creds export -p dev-sandbox)'
#+END_SRC

#+BEGIN_SRC zsh
if exe_exists exa; then
    alias ls='exa -Fl'
else
    alias ls='ls -Fl'
fi

alias cl='clear; ls'

if exe_exists gmake; then
    alias make=gmake
fi
#+END_SRC

[[https://github.com/ajeetdsouza/zoxide][Zoxide]] provides a fuzzy version of =cd=. Because =zoxide= is such a long command, I have it alias itself to =c=.

#+BEGIN_SRC  zsh
if exe_exists zoxide; then
   eval "$(zoxide init zsh --cmd c)"
fi
#+END_SRC

** Prompt

I use [[https://starship.rs][starship]] for a useful contextual prompt. Initializing =starship= is easy:

#+BEGIN_SRC zsh
if exe_exists starship; then
    eval "$(starship init zsh)"
fi
#+END_SRC

=starship= is fully configured from =.config/starship.toml=.

#+BEGIN_SRC toml :tangle .config/starship.toml
# Don't add a newline at the end
add_newline = false

[character]
success_symbol = "[𝛌](bold green)"
error_symbol = ""

[status]
disabled = false
style = "bold red"
symbol = "𝛌"
format = "[$symbol\\($status\\)]($style)"
#+END_SRC

** Syntax Highlighting

#+BEGIN_SRC zsh
local HIGHLIGHT="$HOME/.cache/zsh-syntax-highlighting"
if ! [[ -d "$HIGHLIGHT" ]]; then
    echo "Cloning zsh syntax highlighting into $HIGHLIGHT"
    mkdir -d "$HOME/.cache"
    git clone 'https://github.com/zsh-users/zsh-syntax-highlighting.git' "$HIGHLIGHT"
fi
source $HIGHLIGHT/zsh-syntax-highlighting.zsh
#+END_SRC

* Git

#+BEGIN_SRC conf-unix :tangle .gitconfig
# This is Git's per-user configuration file.
[user]
name = Ian Wahbe
email = <<user-mail-address>>
[github]
	user = iwahbe
[init]
	defaultBranch = main
[pull]
	rebase = false
[rerere]
	enabled = true
#+END_SRC
