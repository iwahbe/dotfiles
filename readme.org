#+AUTHOR: iwahbe
#+PROPERTY: header-args :noweb no-export :mkdirp t
#+PROPERTY: header-args:emacs-lisp :tangle init.el
#+PROPERTY: header-args:zsh :tangle .zshrc
#+PROPERTY: header-args:.gitignore :tangle .gitignore

* Literate Configuration

We want to be able to treat this file especially, so we need to set its name in a variable.

#+BEGIN_SRC emacs-lisp :var this-file=(buffer-file-name)
(defvar =literate-config-file this-file
  "The file that this config was tangled from.")
#+END_SRC

Common file types have common headers and footers. [[help:org-babel-tangle][org-babel-tangle]] has support for post-tangle hooks, but doesn't expose a framework for such hooks. We want such a framework.

Org-babel exposes [[help:org-babel-post-tangle-hook][org-babel-post-tangle-hook]]. We can build a macro on top of that to create easy finalize hooks.

#+BEGIN_SRC emacs-lisp
(defmacro =config-tangle-finalize (&rest body)
  "Define a function to run after tangling a file in this directory.

The first argument to BODY specifies the condition to run the
hook.  Available patterns are:

- (`:ext' EXT): EXT is a symbol that defines the extension for the file.
- (`:name' NAME): NAME is a symbol that specifies the full name of the file.
- (`or' PAT1 ... PATN): PAT_I is one of the available patterns."
  (declare (indent defun))
  (let ((f `(buffer-file-name)))
    `(add-hook 'org-babel-post-tangle-hook
	       (lambda ()
		 (when (and
			(string-prefix-p (expand-file-name user-emacs-directory) ,f)
			,(=config--tangle-condition (car body) f))
		   ,@(cdr body)
		   ;; We need to save the buffer, since this hook runs after the initial
		   ;; babel save
		   (let ((save-silently t) before-save-hook)
		     (save-buffer)))))))
#+END_SRC

The bulk of the work is parsing the condition. We need to define a separate function here because the definition is recursive.

#+BEGIN_SRC emacs-lisp
(defun =config--tangle-condition (condition file-name)
  "Parse CONDITION into a callable function.
FILE-NAME evaluates to the file name under consideration."
  (pcase condition
    (`(:ext ,ext) `(equal (file-name-extension ,file-name t) (symbol-name ',ext)))
    (`(:name ,name) `(equal (file-name-nondirectory ,file-name) (symbol-name ',name)))
    (`(or . ,l) `(or ,@(mapcar (lambda (x) (=config--tangle-condition x file-name)) l)))
    (other (error "Unknown condition: '%s'" other))))
#+END_SRC


Referencing and editing our configuration is a common action (for good or for ill). We bind config navigation.

#+BEGIN_SRC emacs-lisp
(defun =config-heading ()
  "Jump to a config heading."
  (interactive)
  (unless (equal (buffer-file-name) =literate-config-file)
    (find-file-other-window =literate-config-file))
  (consult-org-heading))

(global-set-key (kbd "C-c C") #'=config-heading)
#+END_SRC

** CLI
#+PROPERTY: header-args:sh :tangle "config" :shebang "#!/bin/sh"

We want to provide a script to link generated files into the main directory. Instead of trying to track the files generated during tangling, we provide a simple =sh= script to recursively traverse a directory, adding symlinks as appropriate.

#+BEGIN_SRC sh
# make_link <src> <dst>
#
# Create a link between <src> and <dst>.
# <src> may be a directory.
# <dst> will not exist.
#
# You can override the command used by setting CONFIG_LINK_CMD.
make_link () {
    if [[ "" == "$CONFIG_LINK_CMD" ]]; then
	echo "Linking $1 to $2"
	ln -s -w $1 $2
    else
	$CONFIG_LINK_CMD $1 $2
    fi
}

# unmake_link <src> <dst>
#
# Remove an existing link from <src> to <dst>.
#
# You can override the command used by setting CONFIG_UNLINK_CMD.
unmake_link() {
    if [[ "" == "$CONFIG_UNLINK_CMD" ]]; then
	rm $2
    else
	$CONFIG_UNLINK_CMD $1 $2
    fi
}

# skip_link <src> <dst>
#
# Skip linking from <src> to <dst> because <dst> already exists.
skip_link() {
    echo "Cannot link $1 to $2 because $2 already exists."
}

SRC_DIR=$2
DST_DIR=$3

read -r -d '' HELP <<- EOF
	config [cmd] [src=.] [dst=$HOME]

	Recursivly link src to dst.

	Files in dst are prioritized over files in src.

	Both src and dst must be directories.
EOF

if [[ "$2" == "" ]]; then
    SRC_DIR="."
fi

if [[ "$3" == "" ]]; then
    DST_DIR="$HOME"
fi

if [[ ! -d "$SRC_DIR" ]]; then
    echo "'$SRC_DIR' is not a directory"
    echo
    echo "$HELP"
    exit 1
fi

if [[ ! -d "$DST_DIR" ]]; then
    echo "'$DST_DIR' is not a directory"
    echo
    echo "$HELP"
    exit 1
fi

# process <cmd> <path>
process () {
    if [[ ! -e "$DST_DIR/$2" ]]; then
	# dst doesn't exist, so link the entry.  This can be either a file or a
	# directory.
	"$1" "$SRC_DIR/$2" "$DST_DIR/$2"
    elif [[ -d "$DST_DIR/$2" ]] && [[ -d "$SRC_DIR/$2" ]]; then
	# The dst directory exists,
	for entry in $('ls' "$SRC_DIR/$2"); do
	    if [[ "$2" == "" ]]; then
		process "$1" "$entry"
	    else
		process "$1" "$2/$entry"
            fi
	done
    else
	# We can't recurse down directories, so we give up
	skip_link "$SRC_DIR/$2" "$DST_DIR/$2"
    fi
}

case $1 in
    up)
	process 'make_link' ""
	;;
    down)
	process "unmake_link" ""
	;;
    ,*)
	echo "Unknown command $1"
	echo ""
	echo "$HELP"
	;;
esac
#+END_SRC

* Emacs

** Getting Started

*** Installation

On mac, I use [[https://github.com/d12frosted/homebrew-emacs-plus][homebrew-emacs-plus]] to install Emacs. This is the command I used to install.

#+BEGIN_SRC sh :tangle no
brew install emacs-plus@29     \
     --with-no-frame-refocus   \
     --with-imagemagick        \
     --with-native-comp        \
     --with-poll               \
     --with-memeplex-wide-icon
#+END_SRC

** Literate Configuration

This is a [[http://www.literateprogramming.com][literate]] [[help:user-emacs-directory][config]] for Emacs. This file is the single source of truth for the contents of =.emacs.d=.

#+BEGIN_SRC .gitignore :tangle .gitignore
init.el
early-init.el
#+END_SRC

We want all =emacs-lisp= files to be tangled with the appropriate headers and footers.

- Emacs would like each file to declare its module, and a description.
- All files should use lexical bindings. This makes the code easier to read, and easier for Emacs to interpret, leading to a performance boost.
- Emacs would like each file to declare its end.

#+BEGIN_SRC emacs-lisp
(=config-tangle-finalize (:ext .el)
  (let ((feature (string-remove-suffix
		  ".el" (string-remove-prefix
			 (expand-file-name user-emacs-directory)
			 (buffer-file-name)))))
    ;; Insert the header
    (goto-char (point-min))
    (insert ";;; " feature ".el --- Tangled from init.org -*- lexical-binding: t; -*-\n"
	    "\n"
	    ";;; Commentary:\n"
	    "\n"
	    ";; This file was tangled as part of iwahbe's Emacs config.\n"
	    "\n"
	    ";;; Code:\n"
	    "\n")
    ;; Then insert the footer
    (goto-char (point-max))
    (insert "\n"
	    "(provide '" feature ")\n"
	    ";;; " feature ".el ends here\n"))
  (lisp-indent-region (point-min) (point-max)))
#+END_SRC

Further, we want lexical bindings even when developing interactively. This doesn't do anything when a file is loaded, but it does effect what happens when =eval-last-sexp= is used.

#+BEGIN_SRC emacs-lisp
(setq-default lexical-binding t)
#+END_SRC

I declare a custom helper macro for adding hooks. It simplifies quoting, and allows multiple hooks to be attached in a single /sexp/.

#+BEGIN_SRC emacs-lisp
(defmacro =add-hook (mode &rest hooks)
  "Attach multiple HOOKS to a MODE hook.
It is optional to quote MODE."
  (declare (indent defun))
  `(progn
     ,@(mapcar
	(lambda (hook) `(add-hook
			 ,(if (eq (car-safe mode) 'quote)
			      mode
			    `(quote ,mode))
			 ,hook))
	hooks)))
#+END_SRC

==dbg= isn't used within the config, but it proves a helpful pass-through macro for debugging.

#+BEGIN_SRC emacs-lisp
(defmacro =dbg (form)
  "Print FORM => RES where res is what FORM evaluate to.
Return RES."
  `(let ((res ,form)) (message "dbg: %s => %s" '(,@form) res) res))
#+END_SRC


=(==one-of el p1 p2)= is an efficient implementation of =(memq el (list p1 ... pN))= where =p_i= is computed only for the equality check.

#+BEGIN_SRC emacs-lisp
(defmacro =one-of (el &rest forms)
  "Check if EL is one of FORMS.
The nth form in FORMS is evaluated only if no previous form matched EL.
Each form in FORMS is compared against EL with `eq'."
  (let ((name (gensym "el")))
    `(let ((,name ,el))
       (or ,@(mapcar
	      (lambda (form)
		`(eq ,name ,form))
	      forms)))))
#+END_SRC

The best way to understand how ==one-of= works is too see what it expands into:

#+BEGIN_SRC emacs-lisp :tangle no :results pp :wrap example emacs-lisp
(macroexpand-1
 `(=one-of (get-input) (comp1) (comp2) (comp3)))
#+END_SRC

#+RESULTS:
#+begin_example emacs-lisp
(let
    ((el39
      (get-input)))
  (or
   (eq el39
       (comp1))
   (eq el39
       (comp2))
   (eq el39
       (comp3))))
#+end_example

** Performance

Emacs Lisp is garbage collected. While this is generally fine, I don't need garbage collection runs kicking off during startup. I disable garbage collection during startup.

It is important that we turn off the GC as early as possible, to save as many cycles as possible.

#+BEGIN_SRC emacs-lisp :tangle early-init.el
(setq gc-cons-threshold most-positive-fixnum
      gc-cons-percentage 0.6)
#+END_SRC

We don't want to permanently disable garbage collection, so we re-enable garbage collection after all packages have been loaded.

#+BEGIN_SRC emacs-lisp
(add-hook 'elpaca-after-init-hook
	  (lambda ()
	    (setq gc-cons-threshold 16777216 ; 16mb
		  gc-cons-percentage 0.1)))
#+END_SRC

** Window + Frame Management

A quick glossary for those new to Emacs. Because Emacs predates windowed graphics systems, it uses different terminology then the rest of the world.

In Emacs parlance, the object managed by the OS windowing system is called a *frame*. Each internal pane in a /frame/ is called a *window*.

By default, Emacs thinks in terms of text columns and lines. This isn't great when computing frame sizes for graphical purposes. We want to think in pixels.

#+BEGIN_SRC emacs-lisp :tangle early-init.el
(setq frame-resize-pixelwise t)
#+END_SRC

It is important to set graphical elements in =early-init.el=, since otherwise they take effect after graphics open and the window viably flickers or resizes.

#+BEGIN_SRC emacs-lisp :tangle early-init.el
(tool-bar-mode -1)
(menu-bar-mode -1)
(setq
 frame-resize-pixelwise t
 ;; We set the font here to work around a bug that hides the echo area
 ;; when a font is set after the frame loads.
 default-frame-alist '((font . "Fira Code")
		       (vertical-scroll-bars . nil)
		       (horizontal-scroll-bars . nil))
 initial-frame-alist
      '((width . 0.5) (height . 1.0)
	(top . 0) (left . 1.0)))
#+END_SRC

** Clutter Management

We want to be able to cleanly check this file in.

We have two complementary strategies for this:

1. We direct what we can into a hidden =.cache=.

#+BEGIN_SRC emacs-lisp
(defvar =cache-directory (expand-file-name ".cache" user-emacs-directory)
  "The directory where a system local cache is stored.")

(defun =cache-subdirectory (domain)
  "A stable directory to cache files from DOMAIN in."
  (expand-file-name (concat domain "/") =cache-directory))

(defun =cache-file (file &optional domain)
  "A stable file name for FILE, located in DOMAIN if provided."
  (expand-file-name file
		    (if domain
			(let ((s (=cache-subdirectory domain)))
			  (unless (file-executable-p s)
			    (mkdir s))
			  s)
		      =cache-directory)))
#+END_SRC

2. We add =.cache= and any un-directed file to =.gitignore=.

#+BEGIN_SRC .gitignore :tangle .gitignore
.cache
#+END_SRC

In theory, it is possible to redirect =.eln= files to an arbitrary location using =startup-redirect-eln-cache=, but it hasn't worked for me.

#+BEGIN_SRC .gitignore  :tangle .gitignore
eln-cache
#+END_SRC

For the record, this is the block I tried:

#+BEGIN_SRC emacs-lisp :file early-init.el :tangle no
(when (fboundp 'startup-redirect-eln-cache)
  (startup-redirect-eln-cache (=cache-subdirectory "eln-cache")))
#+END_SRC

Following good practice, we maintain an =assets= folder, where we store /heavy/ files.

#+BEGIN_SRC emacs-lisp
(defvar =assets-directory (expand-file-name "assets" user-emacs-directory)
  "The directory containing large runtime assets, such as images.")
#+END_SRC

Part of clutter management is keeping file buffers up to date with the underlying files. For this, we have [[help:auto-revert-mode][auto-revert-mode]].

#+BEGIN_SRC emacs-lisp
(auto-revert-mode +1)
#+END_SRC

** Package Management

I use [[https://github.com/progfolio/elpaca][elpaca]] as my package manager for Emacs. Like all package managers (except built-in =package.el=, it requires a self-install script to initialize itself.

To avoid cluttering up the =.emacs.d= directory, we have =elpaca= cache in it's own directory.

#+BEGIN_SRC emacs-lisp
(defvar elpaca-directory (=cache-subdirectory "elpaca"))
  #+END_SRC

  This is the install script from the elpaca repo:

#+BEGIN_SRC emacs-lisp
(defvar elpaca-installer-version 0.1)
(defvar elpaca-builds-directory (expand-file-name "builds/" elpaca-directory))
(defvar elpaca-order '(elpaca :repo "https://github.com/progfolio/elpaca.git"
			      :ref nil
			      :files (:defaults (:exclude "extensions"))
			      :build (:not elpaca--activate-package)))
(when-let ((repo  (expand-file-name "repos/elpaca/" elpaca-directory))
	   (build (expand-file-name "elpaca/" elpaca-builds-directory))
	   (order (cdr elpaca-order))
	   ((add-to-list 'load-path (if (file-exists-p build) build repo)))
	   ((not (file-exists-p repo))))
  (condition-case-unless-debug err
      (if-let ((buffer (pop-to-buffer-same-window "*elpaca-installer*"))
	       ((zerop (call-process "git" nil buffer t "clone"
				     (plist-get order :repo) repo)))
	       (default-directory repo)
	       ((zerop (call-process "git" nil buffer t "checkout"
				     (or (plist-get order :ref) "--"))))
	       (emacs (concat invocation-directory invocation-name))
	       ((zerop (call-process emacs nil buffer nil "-Q" "-L" "." "--batch"
				     "--eval" "(byte-recompile-directory \".\" 0 'force)"))))
	  (progn (require 'elpaca)
		 (elpaca-generate-autoloads "elpaca" repo)
		 (kill-buffer buffer))
	(error "%s" (with-current-buffer buffer (buffer-string))))
    ((error) (warn "%s" err) (delete-directory repo 'recursive))))
(require 'elpaca-autoloads)
(add-hook 'after-init-hook #'elpaca-process-queues)
(elpaca `(,@elpaca-order))
#+END_SRC

Worth noting: =elpaca= runs asynchronously, and kicks off after =after-init-hook=.

We need to disable =package.el=, Emacs's default package manager. Since =package.el= sets up existing packages before =init.el= runs, we need to do this in =early-init.el=:

#+BEGIN_SRC emacs-lisp :tangle early-init.el
(setq package-enable-at-startup nil)
#+END_SRC

** Splash Screen

Half of customizing Emacs is making the splash screen look fancy.

We redefine =display-startup-echo-area-message=, since there is no built in way to disable it. To make sure I am cognizant of start-up time, I have this set to display the load time of Emacs.

#+BEGIN_SRC emacs-lisp
(defun display-startup-echo-area-message ()
  "Override the default help message by redefining the called function."
  (message "Loaded %s packages in %f seconds"
	   (length (elpaca--queued))
	   (float-time
	    (time-subtract
	     elpaca-after-init-time
	     before-init-time))))
#+END_SRC

I like the simplicity of a random Emacs-related image on screen. I'm not willing to give up on supporting text only situations (such as in the terminal). To that end, there is a fall-back option to display only text.

#+BEGIN_SRC emacs-lisp
(defun =splash-buffer (&optional window)
  "The splash screen.
It is assumed that the splash screen will occupy the whole frame
when it is created.
WINDOW is passed via `window-size-change-functions'.  It is ignored."
  (ignore window)
  (if (not (=one-of (current-buffer)
	    (get-buffer "*scratch*")
	    (get-buffer "*Splash Screen*")))
      ;; If the current buffer is not *scratch*, then Emacs was opened
      ;; onto a file, so we should just display that file.
      (current-buffer)
    (with-current-buffer (get-buffer-create "*Splash Screen*")
      (read-only-mode)
      (make-local-variable 'window-size-change-functions)
      (add-to-list 'window-size-change-functions #'=splash-buffer)
      (let ((inhibit-read-only t))
	(unless (eq (buffer-size) 0)
	  (erase-buffer))
	(if (and (display-graphic-p) (featurep 'image))
	    (=splash-buffer--graphic)
	  (=splash-buffer--text))
	(setq cursor-type nil)
	(goto-char (point-min))
	(setq mode-line-format nil)
	(current-buffer)))))
#+END_SRC

Emacs uses =initial-buffer-choice= to determine what buffer it should start in.

#+BEGIN_SRC emacs-lisp
(setq initial-buffer-choice #'=splash-buffer)
#+END_SRC

*** Graphics

Here we want to insert a random image from our list of graphic banner images. Graphic banner images are stored in the =assets= folder. We define our list of images.

#+BEGIN_SRC emacs-lisp
(defvar =emacs-graphic-banners
  (mapcar (lambda (x) (expand-file-name x =assets-directory))
	  '("gnu-head.svg"
	    "emacs-icon.svg"))
  "A list of graphical banners to open Emacs with.
Each element is expected to be the path to a SVG file.")

(defvar =emacs-graphic-banner
  (nth (random (length =emacs-graphic-banners))
       =emacs-graphic-banners)
  "The randomly chosen graphic banner to use for this session.
This is calculated once, so it doesn't change during redisplay.")
#+END_SRC

We then define what a graphic splash buffer will be: A centered image 1/3 down the frame.

#+BEGIN_SRC emacs-lisp
(defun =splash-buffer--graphic ()
  "Display the splash screen with graphics."
  (let* ((img
	  (create-image
	   =emacs-graphic-banner
	   nil nil :width (* (/ (frame-pixel-width) 3) 2)))
	 (img-size (image-size img))
	 (img-width (round (car img-size)))
	 (img-height (round (cdr img-size))))
    ;; We want to center the image around 1/3 down the
    ;; screen. Since the image insert holds the top of the
    ;; image, we need to adjust the insert point by adding
    ;; newlines.
    (insert (make-string (max (- (/ (frame-height) 3) (/ img-height 2)) 0) ?\n))
    ;; Likewise, we want to insert the image in the center of
    ;; the screen but the image inserts from the left. We pad
    ;; our insert point with spaces.
    (insert (make-string (max (- (/ (frame-width) 2) (/ img-width 2)) 0) ? ))
    (insert-image img nil nil nil t)))
    #+END_SRC

*** Text

Text banners are stored inline with in =init.el=. They were generated from [[https://patorjk.com/software/taag/#p=display&f=Graffiti&t=Emacs][patorjk.com/software/taag]].

#+BEGIN_SRC emacs-lisp
(defvar =emacs-text-banners
  '(("███████╗███╗   ███╗ █████╗  ██████╗███████╗"
     "██╔════╝████╗ ████║██╔══██╗██╔════╝██╔════╝"
     "█████╗  ██╔████╔██║███████║██║     ███████╗"
     "██╔══╝  ██║╚██╔╝██║██╔══██║██║     ╚════██║"
     "███████╗██║ ╚═╝ ██║██║  ██║╚██████╗███████║"
     "╚══════╝╚═╝     ╚═╝╚═╝  ╚═╝ ╚═════╝╚══════╝")
    ("  _______  ___      ___       __       ______    ________  "
     " /\"     \"||\"  \\    /\"  |     /\"\"\\     /\" _  \"\\  /\"       ) "
     "(: ______) \\   \\  //   |    /    \\   (: ( \\___)(:   \\___/  "
     " \\/    |   /\\\\  \\/.    |   /' /\\  \\   \\/ \\      \\___  \\    "
     " // ___)_ |: \\.        |  //  __'  \\  //  \\ _    __/  \\\\   "
     "(:      \"||.  \\    /:  | /   /  \\\\  \\(:   _) \\  /\" \\   :)  "
     " \\_______)|___|\\__/|___|(___/    \\___)\\_______)(_______/   "))
  "A list of non-graphical banners.
Each banner is expected to be a list of text, where each text
element is a single line.")

(defvar =emacs-text-banner
  (nth (random (length =emacs-text-banners)) =emacs-text-banners)
  "The text banner to use for this session.
This is calculated once so it doesn't change during redisplay")
#+END_SRC

The display function is similar to the graphic version, aiming to put the text centered 1/3 down the frame.

#+BEGIN_SRC emacs-lisp
(defun =splash-buffer--text ()
  "Display the splash screen with only text."
  (let ((banner =emacs-text-banner)
	(empty-line "\n"))
    (dotimes (_ (- (/ (frame-height) 3) (/ (length banner) 2) 2))
      (insert empty-line))
    (mapc (lambda (x) (insert x "\n")) banner))
  (let ((fill-column (frame-width)))
    (center-region (point-min) (point-max))))
#+END_SRC

** UI

I understand what the scratch buffer does, so the explanation is not necessary.

#+begin_src emacs-lisp
(setq initial-scratch-message nil)
#+end_src

I don't need the additional delay of typing "es" or "o". "y" or "n" is sufficient.

#+BEGIN_SRC emacs-lisp
(fset #'yes-or-no-p #'y-or-n-p)
#+END_SRC

Text editors should not make sound.

#+BEGIN_SRC emacs-lisp
(setq ring-bell-function #'ignore)
#+END_SRC

*** Theme

Emacs uses a concept called a =theme= to control system appearance. Each theme applies a layer of =face= description to the loaded buffer. The ordered list of enabled themes is defined in =custom-enabled-themes=.

When I load a theme, I only want that theme to apply. I don't want the previous theme to effect the current experience. To solve this, I define a =load-theme= wrapper called ==load-theme=.

#+BEGIN_SRC emacs-lisp
(defun =load-theme (theme)
  "Load THEME without asking for permission."
  (load-theme (pcase theme
		('light 'spacemacs-light)
		('dark 'spacemacs-dark)
		(other other))
	      t)
  ;; Disable previous themes
  (mapc #'disable-theme (cdr custom-enabled-themes)))
#+END_SRC

I'm currently using [[https://github.com/nashamri/spacemacs-theme][spacemacs-theme]], both light and dark as my goto-theme.

#+BEGIN_SRC emacs-lisp
(elpaca spacemacs-theme
#+END_SRC

Mac has a concept of light and dark mode at the system level. Emacs can be built with hooks to support system appearance change. I want use these hooks when available.

#+BEGIN_SRC emacs-lisp
  (if (boundp 'ns-system-appearance)
      (=add-hook ns-system-appearance-change-functions #'=load-theme)
#+END_SRC

When there isn't any system input for the theme, we will just load the ='light= theme by default.

#+BEGIN_SRC emacs-lisp
    (=load-theme 'light)))
#+END_SRC

*** Cursor

I expect the cursor to be static, and I prefer a bar over a block.

#+BEGIN_SRC emacs-lisp
(setq-default cursor-type 'bar)
(blink-cursor-mode -1)
#+END_SRC

** Modeline

Current customization is basic, and worth revisiting.

I need to know the line and column number.

#+BEGIN_SRC emacs-lisp
(line-number-mode +1)
(column-number-mode +1)
#+END_SRC

** Introspection

Emacs is famously introspectable. This is facilitated by the =describe-*= functions. The built in introspection is excellent, but it can be improved by showing more information about the values variables hold. The main improvement available is showing the source code where the inspected item is defined. This is what [[https://github.com/Wilfred/helpful][Wilfred/helpful]] does.

#+BEGIN_SRC emacs-lisp
(elpaca helpful
  (global-set-key [remap describe-function] #'helpful-callable)
  (global-set-key [remap describe-key] #'helpful-key)
  (global-set-key [remap describe-variable] #'helpful-variable)
  (global-set-key [remap describe-command] #'helpful-command))
#+END_SRC

Since we are happy with default bindings here, we just remap the existing binding to the =helpful= variant.

** Native compilation

Emacs has support for native compilation of elisp code. This feature leads to a noticeable speedup in performance dependent packages, such as =eglot= and =jsonian=. Emacs compiles elisp code asynchronous in the background when a package is loaded.

We don't want to see compilation errors pop up for existing packages we have, since they are generally not actionable. We instead shunt them into the =*Warnings*= buffer.

#+BEGIN_SRC emacs-lisp
(setq native-comp-async-report-warnings-errors 'silent)
#+END_SRC

** Movement

Emacs defines a multitude of ways to navigate around, but I often find it lacking in certain respects.

*** TODO Windows

*** Jump to character

One thing I miss from =vim= is the ability to easily jump between and around characters. I have written a small package to accomplish this, called /GoTo Quickly/, and I load that now.

#+BEGIN_SRC emacs-lisp
(load (expand-file-name "gtq.el" user-emacs-directory))
#+END_SRC

It defines =gtq-goto=, which brings up a model interface for quickly navigating among characters.

#+BEGIN_SRC  emacs-lisp
(global-set-key (kbd "C-'") #'gtq-goto)
#+END_SRC

If the package proves useful, I will expand it and probably add more bindings, but right not it's pretty simple.

** Whitespace

Trailing whitespace is generally wrong. However, I need to be careful that I don't have lots of whitespace diffs on shared files. =ws-butler= handles this nicely.

Since the package is unmaintained, I use hlissner's (of Doom Emacs fame) fork, on the grounds that since it is used by a popular distribution, it will probably work.

#+BEGIN_SRC emacs-lisp
(elpaca (ws-butler :host github :repo "hlissner/ws-butler")
#+END_SRC

It is enabled everywhere.

#+BEGIN_SRC emacs-lisp
  (ws-butler-global-mode))
#+END_SRC

I use =fill-paragraph= often. It defaults to /70/ characters, which is too conservative for me.

#+BEGIN_SRC emacs-lisp
(setq-default fill-column 90)
#+END_SRC

** Session persistence & Backups

By default, Emacs scatters backup and auto-save files over the directory in use, but does not remember useful information such as where I was last I edited the buffer. This needs to be fixed.

=save-place-mode= is a built-in global minor mode to save the position of point in a buffer, and to persist that between sessions. It does that by writing each buffer position to a file, and then referring to the file when a buffer is revisited. This is fine, but we want to redirect the file to our cache.

#+BEGIN_SRC emacs-lisp
(setq save-place-file (=cache-file "places"))
(save-place-mode +1)
#+END_SRC

I move all auto-saves into a centralized directory that I know is /not/ under source control.

#+BEGIN_SRC emacs-lisp
(setq auto-save-list-file-prefix
      (concat (=cache-subdirectory "auto-save-list") ".saves-"))
#+END_SRC

Similarly, I move all backups to a cache directory.

The ="."= means that this is the backup location for files in all directories.

#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist `(("." . ,(=cache-subdirectory "backup"))))
#+END_SRC

** Project Management

As far as I know, Emacs has two project management solutions: [[https://github.com/bbatsov/projectile][projectile]] and [[https://github.com/emacs-mirror/emacs/blob/master/lisp/progmodes/project.el][project.el]]. Because =project.el= is in-trunk, I have decided to use it. It works out of the box, but I still needed a couple of tweaks.

=project.el= caches which projects have been accessed, which needed to be re-mapped into the cache directory.

#+BEGIN_SRC emacs-lisp
(setq project-list-file (=cache-file "projects"))
#+END_SRC

When a project is entered, =project-switch-commands= is used to determine what dialog is displayed to the user.

Before a switch command is executed, I set =default-directory= to the project I just switched to. This enables commands like =magit= and =vterm= to kick off in the new project.

#+BEGIN_SRC emacs-lisp
(defun =project-set-switch-commands (pallet)
  "Set `project-switch-commands'.

This function alters the commands passed in via PALLET to make
them aware of the new project."
  (setq project-switch-commands
	(mapcar
	 (lambda (x) (cons
		      (lambda ()
			(interactive)
			(let ((default-directory
			       (or project-current-directory-override
				   default-directory)))
			  (funcall-interactively (car x))))
		      (cdr x)))
	 pallet)))
#+END_SRC

We now define the actual command pallet we want.

#+BEGIN_SRC emacs-lisp
(=project-set-switch-commands
      '((project-find-file "Find file" "f")
	(consult-find "`find` file" "C-f")
	(consult-ripgrep "Find regexp" "g")
	(magit "Git" "v")
	(vterm "Shell" "t")))
#+END_SRC

** Completion

A lot of Emacs customization goes into Emacs, which impressively does nothing out of the box.

*** Completion at point

For completion at point, there are two main options: [[https://github.com/minad/corfu][corfu]] and [[https://company-mode.github.io][company]]. =company= is by far the 800 pound gorilla in this fight with a large number of custom backends.  I have decided to use =corfu= instead, since it integrates with Emacs's existing =completion-at-point-functions=.

#+BEGIN_SRC emacs-lisp
(elpaca corfu
#+END_SRC

I prefer aggressive completion.

#+BEGIN_SRC emacs-lisp
(setq corfu-auto t          ;; Complete when available
      corfu-auto-delay 0    ;; Without any delay
      corfu-auto-prefix 1)  ;; Wait only for the first character
#+END_SRC

I want completion to be enabled everywhere.

#+BEGIN_SRC emacs-lisp
(global-corfu-mode)
#+END_SRC

Finally, I want completion to not interfere with my normal typing. By default, return finalizes a completion. I find this super disruptive, since I often want to type =RET=, even when a completion is prompted. The solution is to unbind =RET= and rebind a less intrusive option. I use control-space.

This unbinds ="RET"= in the map =corfu= uses during completion. The trailing =t= ensures that we are removing this binding, not just setting it to =nil=. This allows fallback to other keymaps (such as the =self-insert-command= in the =global-mode-map=).

#+BEGIN_SRC emacs-lisp
(define-key corfu-map (kbd "RET") nil t)
#+END_SRC

I then apply the correct bindings for Ctrl-Space. Unfortunately, there doesn't seem to be a binding that applies to both the terminal and the GUI, so I apply a separate binding for both.

#+BEGIN_SRC emacs-lisp
(dolist (spc '("C-@" "C-SPC"))
  ;; C-@ works in the terminal, but not in GUI.
  ;; C-SPC works in GUI, but not in the terminal.
  (define-key corfu-map (kbd spc) #'corfu-insert)))
#+END_SRC

=corfu= only works on a GUI. When I don't have access to a GUI, I load [[https://codeberg.org/akib/emacs-corfu-terminal][corfu-terminal]] to get the graphics to stay consistent.

#+BEGIN_SRC emacs-lisp
(unless (display-graphic-p)
  ;; Since we don't need the additional mode on GUI, only download it
  ;; when on a TTY.
  (elpaca (corfu-terminal
	   :type git
	   :repo "https://codeberg.org/akib/emacs-corfu-terminal.git")
    (corfu-terminal-mode +1)))
#+END_SRC

*** TODO Minibuffer completion

#+BEGIN_SRC emacs-lisp
;; A vertical completion framework, applying a nicer UX to default
;; compleating-read style completion.
(elpaca vertico
  (setq vertico-cycle t)
  (vertico-mode))

;; Helpful information in the margin of `vertico' completions.
(elpaca marginalia (marginalia-mode))

(elpaca orderless
  (setq completion-styles '(orderless basic)
	completion-category-overrides '((file (styles basic partial-completion)))))
#+END_SRC

*** Enhanced consulting completion

[[https://github.com/minad/consult][consult]] is a utility package that provides a boat load of /improved/ consulting commands. I rebind several existing built-in commands with their =consult= equivalent.

#+BEGIN_SRC emacs-lisp
(elpaca consult
  (global-set-key [remap goto-line] #'consult-goto-line)
  (global-set-key [remap Info-search] #'consult-info)
  (global-set-key [remap yank-pop] #'consult-yank-pop)
  (global-set-key [remap imenu] #'consult-imenu)

  ;; By default, consult applies the prefix ?# to all registers, which
  ;; is not necessary.
  (setq consult-register-prefix nil)

  (global-set-key [remap jump-to-register] #'consult-register-load)
  (global-set-key [remap switch-to-buffer] #'consult-buffer)
  (global-set-key [remap switch-to-buffer-other-frame] #'consult-buffer-other-frame)
  (global-set-key [remap switch-to-buffer-other-window] #'consult-buffer-other-window)
  (define-key isearch-mode-map [remap isearch-edit-string] #'consult-isearch-history))
#+END_SRC

** Major Modes

Emacs defines the general behavior of each buffer with a =major-mode= (stored in a variable of the same name). In general, each language defines a major mode, as well as Emacs specific interaction environments like =dired= and =magit=. Major modes support inheritance, with all modes derived from =fundamental-mode=.

*** Text Mode

Text mode is the parent mode for unstructured text.

We want spelling support for text all text modes, so we turn on =flyspell-mode= for =text-mode=. This applies for all derived modes as well.

#+BEGIN_SRC emacs-lisp
(=add-hook 'text-mode-hook
  #'flyspell-mode
  #'visual-line-mode)
#+END_SRC

*** Programming Mode

=prog-mode= is for writing structured text for a computer to read (programs). All programming language major modes and most data format major modes are ultimately derived from =prog-mode=.

For programming, we want spellcheck for strings and comments, but not necessarily for all text (such as variable names). Flyspell provides =flyspell-prog-mode= for this purpose.

#+BEGIN_SRC emacs-lisp
(=add-hook prog-mode-hook #'flyspell-prog-mode)
#+END_SRC

Programming languages introduce a new type of error: syntax errors. This is handled by =flymake=, which we enable for all programming languages.

#+BEGIN_SRC emacs-lisp
(=add-hook prog-mode-hook #'flymake-mode)
#+END_SRC

**** Tree Sitter

Emacs 29 includes built-in support for [[https://tree-sitter.github.io/tree-sitter/][tree-sitter]], under the =treesit= prefix. Paradoxically, they enable some tree sitter modes by default, but don't bundle the appropriate grammars into Emacs. This means that an unconfigured Emacs errors when opening a =.ts= file.

=emacs -Q bad-decision.ts=  fails with

#+BEGIN_QUOTE
 ■  Warning (treesit): Cannot activate tree-sitter, because language definition\
 for typescript is unavailable (not-found): (libtree-sitter-typescript.so libtr\
ee-sitter-typescript.dylib) No such file or directory
#+END_QUOTE

We need to define the set of valid language grammars.

#+BEGIN_SRC emacs-lisp
(setq treesit-language-source-alist
      '((typescript . ("https://github.com/tree-sitter/tree-sitter-typescript" "master" "typescript/src"))
	(tsx        . ("https://github.com/tree-sitter/tree-sitter-typescript" "master" "tsx/src"))))
#+END_SRC

By default, =treesit= installs grammars in =(expand-file-name "tree-sitter" user-emacs-directory)=. We want to redirect this to a directory in =.cache=.

#+BEGIN_SRC emacs-lisp
(defvar =treesit-language-cache (=cache-subdirectory "tree-sitter")
  "The directory to cache compiled tree-sitter language files.")

(add-to-list 'treesit-extra-load-path =treesit-language-cache)

(advice-add #'treesit--install-language-grammar-1 :around
	    (lambda (fn out-dir &rest args)
	      (apply fn (or out-dir =treesit-language-cache) args)))
#+END_SRC

*** Emacs Lisp

=emacs-lisp-mode= is the major mode used when editing Emacs lisp. Emacs is already pretty good at editing lisps (kind of it's thing). It is pretty stingy on syntax highlighting though, which is especially painful for a heavily dynamic language. I use [[https://github.com/Fanael/highlight-defined][highlight-defined]] to highlight symbols that are known to be defined in the current session.

By default, =highlight-defined= uses its own set of faces. I don't want to spend the effort to maintain a custom set of faces. Setting =highligh-defined-face-use-itself= restores the default faces. This effectively sets =highlight-defined-${KIND}-name-face= to =font-lock-${KIND}-name-face=.

#+BEGIN_SRC emacs-lisp
(elpaca highlight-defined
  (setq highlight-defined-face-use-itself t) ;; Use standard faces when highlighting.
  (=add-hook emacs-lisp-mode-hook #'highlight-defined-mode))
#+END_SRC

*** JSON

I maintain my own major mode for json: =jsonian=. It has some cool features, but the major win is working well in large buffers.

To avoid recomputing strings vs keys, =jsonian= can use existing syntax highlighting as pre-computed indexes. Unfortunately, the Emacs 29 version bump changed how =font-lock= applied, and broke this optimization. I disable it on newer Emacs versions.

#+BEGIN_SRC emacs-lisp
(elpaca jsonian
  (setq jsonian-ignore-font-lock (>= emacs-major-version 29)))
#+END_SRC

*** Git

[[https://magit.vc][Magit]] is everyone's favorite git client, and I'm no exception.

#+BEGIN_SRC emacs-lisp
(elpaca magit)
#+END_SRC

I often share code snippets from GitHub repos. It is helpful to be able to link to snippets without going to [[https://github.com][github.com]], and GitHub maintains a stable and easily compute-able link format.

GitHub formats repo links like so:

#+BEGIN_SRC
github.com/${ORG}/${REPO}/blob/${COMMIT-SHA}/${FILE_PATH}#L${LINE_START}[-L${LINE_END}]
#+END_SRC

We can quickly and easily retrieve this information. The =(interactive "r")= tells Emacs that this function should accept the current region when called interactively. We save the generated URL into the =kill-ring=, and print it to the screen.

#+BEGIN_SRC emacs-lisp
(defun =github-code-region (start end)
  "Copy the GitHub permalink of the highlighted region into the `kill-ring'.
Operate on the region defined by START to END."
  (interactive "r")
  (let ((line-start (line-number-at-pos start t))
        (line-end (line-number-at-pos end t))
        (commit (magit-git-string "rev-parse" "--verify" "HEAD"))
        (path (magit-current-file))
        (url (car-safe (magit-config-get-from-cached-list "remote.origin.url"))))
    (unless url
      (user-error "Could not get remote URL"))
    (kill-new
     (format "%s/blob/%s/%s#L%d%s"
             (string-trim-right url (regexp-quote ".git")) commit path line-start
             (if (= line-start line-end)
                 ""
	       (format "-L%d" line-end))))
    (message "Github link to region: %s" (car kill-ring))))
#+END_SRC

**** Transient

Magit handles it's lovely UX with a subsidiary package: [[https://github.com/magit/transient][transient]], which caches its history locally. We need to remap this into =.cache= to keep =.emacs.d= clean. We don't need to =require= transient ourselves, since Magit depends on it.

#+BEGIN_SRC emacs-lisp
;; Transient does not define it's own history dir, so we do it ourselves.
(defvar =transient-cache-dir (=cache-subdirectory "transient")
  "The directory where transient history files are stored.")
(setq
 transient-history-file (expand-file-name "history.el" =transient-cache-dir)
 transient-values-file (expand-file-name "values.el" =transient-cache-dir)
 transient-levels-file (expand-file-name "levels.el" =transient-cache-dir))
#+END_SRC

*** Org Mode

[[https://orgmode.org][org-mode]] is a staple of Emacs, providing a todo list, calendar, literate programming environment and much more. =org-mode= comes built-in to Emacs, but I think it's worth opting into a more developed version.

#+BEGIN_SRC emacs-lisp
(elpaca org)
#+END_SRC

=org-mode= is structured around putting all your =.org= files into a single directory. It isn't required, but I generally do it anyway. The default value is =~/org=, but I prefer =~/Documents/org=, since it is synced by iCloud. This makes my =.org= files accessible on my iPhone and iPad.

#+BEGIN_SRC emacs-lisp
(setq org-directory "~/Documents/org"
      org-id-locations-file (=cache-file "id-locations" "org"))
#+END_SRC

**** Readability

=org-mode= is primarily used for reading, so it's worth making it look as nice as possible.

I hide markup text such as =*=, =/= and ===.

#+BEGIN_SRC emacs-lisp
(setq org-hide-emphasis-markers t)
#+END_SRC

Similarly, we can render pretty equations like =(\alpha - \beta) \div \Omega=.

#+BEGIN_SRC emacs-lisp
(setq org-pretty-entities t)
#+END_SRC

We would prefer that org renders headings as =✿ Foo= then =***✿ Foo=.

#+BEGIN_SRC emacs-lisp
(setq org-hide-leading-stars t)
#+END_SRC

I replace stand org bullets with graphical overlays.

#+BEGIN_SRC emacs-lisp
(elpaca org-bullets (=add-hook org-mode-hook #'org-bullets-mode))
#+END_SRC

I would prefer that org is read with variable width text, but I need source blocks and tables to be rendered with fixed width text. This can be accomplished by overriding org text properties.

This solution was inspired by [[https://zzamboni.org/post/beautifying-org-mode-in-emacs/][zzamboni]].

#+BEGIN_SRC emacs-lisp
(custom-theme-set-faces
 'user
 '(variable-pitch ((t (:family "Helvetica"))))
 '(fixed-pitch ((t ( :family "Fira Code Retina"))))
 '(org-block ((t (:inherit fixed-pitch))))
 '(org-code ((t (:inherit (shadow fixed-pitch)))))
 '(org-document-info ((t (:foreground "dark orange"))))
 '(org-document-info-keyword ((t (:inherit (shadow fixed-pitch)))))
 '(org-indent ((t (:inherit (org-hide fixed-pitch)))))
 '(org-link ((t (:foreground "royal blue" :underline t))))
 '(org-meta-line ((t (:inherit (font-lock-comment-face fixed-pitch)))))
 '(org-property-value ((t (:inherit fixed-pitch))) t)
 '(org-special-keyword ((t (:inherit (font-lock-comment-face fixed-pitch)))))
 '(org-table ((t (:inherit fixed-pitch :foreground "#83a598"))))
 '(org-tag ((t (:inherit (shadow fixed-pitch) :weight bold :height 0.8))))
 '(org-verbatim ((t (:inherit (shadow fixed-pitch))))))
#+END_SRC

I can now safely enable variable pitch mode.

#+BEGIN_SRC emacs-lisp
(=add-hook org-mode-hook #'variable-pitch-mode)
#+END_SRC

**** Org as a ToDo App

=org-mode= defines a =TODO= item as any header that begins with a todo /keyword/.  The keywords are defines as so.

#+BEGIN_SRC emacs-lisp
(setq org-todo-keywords
      '((sequence "TODO(t)" "WAIT(w)" "DONE(d)")
	(type "PROJ(p)")
	(type "KILL(k)")
	(type "LOOP(l)")))
#+END_SRC

I want to leave a small note every time a =TODO= changes state.

#+BEGIN_SRC emacs-lisp
(setq org-log-done 'note)
#+END_SRC

**** Org Agenda

=org-agenda= is a component of =org-mode= that displays =TODO= elements as part of a time view.

I scatter =TODO= elements all over my org files, so I need to tell =org-mode= which directories it should search through.

#+BEGIN_SRC emacs-lisp
(setq org-agenda-files (list org-directory))
#+END_SRC

I generally use it to discover what I need to do this week, so I tell it to work in increments of a week.

#+BEGIN_SRC emacs-lisp
(setq org-agenda-span 'week)
#+END_SRC

**** Source Blocks

Org allows embedded source blocks, framed by =#+BEGIN_SRC= and =#+END_SRC=.

By default, they are indented, but this is confusing since it doesn't match other text (which is not). I disable source indentation:

#+BEGIN_SRC emacs-lisp
(setq org-src-preserve-indentation t)
#+END_SRC

**** Org Roam

Org-roam is a [[https://en.wikipedia.org/wiki/Zettelkasten][zettelkasten]] based notes system. It is an extension to =org-mode=.

#+BEGIN_SRC emacs-lisp
(elpaca org-roam
  (setq org-roam-directory (expand-file-name "roam" org-directory)
	org-roam-db-location (=cache-file "roam.db" "org"))
  ;; `org-roam-node-list' is called before a list of nodes is displayed to the user. We
  ;; use it as a prompt to turn on database syncing without slowing down startup.
  (advice-add #'org-roam-node-list :before (lambda (&rest _) (org-roam-db-autosync-mode +1))))
#+END_SRC

**** Utilities

This is a utility function to resolve GH links to their issue name.

TODO Combine ==org-describe-link= with =org-link-make-description-function= to get the desired behavior by default.

#+BEGIN_SRC emacs-lisp
(defun =org-describe-link ()
  "Heuristically add a description to the `org-mode' link at point."
  (interactive)
  (when-let* ((ctx (org-element-context))
              (type (org-element-type ctx))
	      (link (org-element-property :raw-link ctx))
	      (description (pcase link
			     ;; This is an https: link to a github issue, so we can use
			     ;; `gh` to get the issue title and display that as the
			     ;; description.
			     ((pred (string-match
				     "https://github.com/\\([-a-zA-Z0-9]+\\)/\\([-a-zA-Z0-9]+\\)/issues/\\([0-9]+\\)"))
			      (with-temp-buffer
				(unless (equal 0
					       (call-process
						(executable-find "gh") nil t nil
						"issue" "view" (substring link (match-beginning 3) (match-end 3))
						(concat "--repo="
							(substring link (match-beginning 1) (match-end 1))
							"/"
							(substring link (match-beginning 2) (match-end 2)))
						"--json=title"))
				  (user-error "Failed to get title from GH"))
				(goto-char (point-min))
				(alist-get 'title (json-parse-buffer :object-type 'alist))))
			     ;; Unable to describe link, so let the user do it
			     (_
			      (message "No option matched to describe the link at point: %s" link)
			      nil))))
    (save-excursion
      (delete-region (org-element-property :begin ctx)
		     (org-element-property :end ctx))
      (org-insert-link link link description))))
#+END_SRC


*** Terminal

There are quite a few different terminal emulators for Emacs, from the built in =term= to the fully Emacs Lisp based shell =eshell=. I prefer [[https://github.com/akermu/emacs-libvterm][vterm]], an Emacs integration of the [[https://launchpad.net/libvterm][libvterm]] C99 library. It acts as a fully function unconstrained terminal, just like =Termnial.app= or [[https://github.com/alacritty/alacritty][Alacritty]].

#+BEGIN_SRC emacs-lisp
(elpaca vterm
  <<defun-term>>)
#+END_SRC

=vterm= isn't project aware, but I would prefer that it was. This can be accomplished by advising the =vterm= function.

#+NAME: defun-term
#+BEGIN_SRC emacs-lisp
(defun =advice--vterm (fn &rest args)
  "Advice for `vterm'.
Redirect the `default-directory' of `vterm' to be project aware.
Fix the naming of the resulting buffer to be project unique.

FN is the original `vterm' function.
ARGS are it's arguments."
  (if-let ((project (project-current)))
      (let ((default-directory (project-root project))
	    (vterm-buffer-name (concat "*vterm<" (project-name project) ">*")))
	(apply fn args))
    (apply fn args)))
(advice-add #'vterm :around #'=advice--vterm)
#+END_SRC

We ensure that =vterm= buffers are cleaned up when they are a part of a project by adding them to =project-kill-buffers=.

#+NAME: kill-vterm
#+BEGIN_SRC emacs-lisp
(require 'project)
(add-to-list 'project-kill-buffer-conditions
	     '(and
	       (derived-mode . vterm-mode)
	       "^\\*vterm<.*>\\*$"))
#+END_SRC

It is possible to integrate Emacs's =default-directory= with =vterm=, but it requires shell side support. Specifically, the running shell needs to =source= a file that =vterm= includes. We make this easier by projecting that file into =vterm='s environment.

#+BEGIN_SRC emacs-lisp
(setq vterm-environment
      (list (concat "VTERM_DATA="
		    (expand-file-name "repos/emacs-libvterm/etc/emacs-vterm-zsh.sh"
				      elpaca-directory))))
#+END_SRC

I then utilize this variable in my =.zshrc= file:

#+BEGIN_SRC zsh
if [[ "$INSIDE_EMACS" = vterm ]]; then
    src="$VTERM_DATA"
    if [[ -f "$src" ]]; then
        source "$src"
    else
        echo "Could not find vterm fish file to source: $src"
    fi
fi
#+END_SRC

*** Go

I need a major mode: =go-mode=.

#+BEGIN_SRC emacs-lisp
(elpaca go-mode)
#+END_SRC

 I hook up =eglot= for serving =lsp= and a format on save hook.

#+BEGIN_SRC emacs-lisp
(=add-hook go-mode-hook
  #'eglot-ensure
  (lambda () (add-hook 'before-save-hook #'gofmt-before-save nil t)))
#+END_SRC

*** Markdown

=markdown-mode= provides Markdown support.

#+BEGIN_SRC emacs-lisp
(elpaca markdown-mode
#+END_SRC

This snippet automatically activates =markdown-mode= for files ending in =.markdown=, =.md=.

#+BEGIN_SRC emacs-lisp
  (autoload 'markdown-mode "markdown-mode"
    "Major mode for editing Markdown files" t)
  (add-to-list 'auto-mode-alist '("\\.markdown\\'" . markdown-mode))
  (add-to-list 'auto-mode-alist '("\\.md\\'" . markdown-mode))
#+END_SRC

Because GitHub is so dominant, I assume that any =README.md= is going in GitHub, and use GitHub Flavored Markdown (GFM). I'm not sure if I intend to keep this snippet, but it was recommended by =markdown-mode='s website.

#+BEGIN_SRC emacs-lisp
  (autoload 'gfm-mode "markdown-mode"
    "Major mode for GitHub Flavored Markdown files" t)
  (add-to-list 'auto-mode-alist '("README\\.md\\'" . gfm-mode)))
#+END_SRC

*** YAML

#+BEGIN_SRC emacs-lisp
(elpaca yaml-mode)
#+END_SRC

** Pulumi

I currently work for [[https://www.pulumi.com][Pulumi]], and I define a set of special functions to work specifically with Pulumi specific data formats.

Pulumi defines its providers with a [[https://www.pulumi.com/docs/guides/pulumi-packages/schema/][schema]]. This function follows internal schema links by leveraging  [[JSON][jsonian]].

#+BEGIN_SRC emacs-lisp
(defun =pulumi-follow-schema-link ()
  "Follow a link in the pulumi schema."
  (interactive)
  (unless (derived-mode-p 'jsonian-mode)
    (user-error "Requires `jsonian-mode'"))
  (if-let* ((pos (jsonian--string-at-pos))
            (s (buffer-substring-no-properties (1+ (car pos)) (1- (cdr pos))))
            (seperator (string-search "/" s 3))
            (path (concat "[\"" (substring s 2 seperator) "\"]" "[\"" (substring s (1+ seperator)) "\"]")))
      (jsonian-find path)
    (user-error "Something went wrong")))
#+END_SRC

Pulumi has repos, so many repos. Often, working on a bug in one repository requires linking in several others. These functions make adding go module [[https://go.dev/ref/mod#go-mod-file-replace][replace]] directives to other Pulumi repositories easy.

#+BEGIN_SRC emacs-lisp
(defun =pulumi-go-src-root ()
  "The root of the pulumi go src."
  (expand-file-name
   "src/github.com/pulumi"
   (or
    (getenv "GOPATH")
    (expand-file-name
     "go"
     (expand-file-name
      user-login-name
      "/Users" )))))

(defun =pulumi-go-projects ()
  "A list of go project paths under the pulumi org."
  (seq-map #'car
           (seq-filter (lambda (attr)
                         (and
                          (cadr attr) ;; A directory
                          (not (member (car attr) '("." ".." "templates")))))
                       (directory-files-and-attributes (=pulumi-go-src-root)))))

(defun =pulumi-go-modules (dir depth)
  "A list of go paths contained in the directory.
DEPTH specifies how many levels to search through."
  (when (and dir (>= depth 1) (file-directory-p dir))
    (let ((root (expand-file-name "go.mod" dir)))
      (if (file-exists-p root)
          (with-temp-buffer
            (insert-file-contents-literally root)
            (search-forward-regexp "^module \\(.+\\)$")
            (list
             dir
             (buffer-substring
              (match-beginning 1)
              (match-end 1))))
        (flatten-list
         (seq-filter #'identity
                     (seq-map
                      (lambda (x) (=pulumi-go-modules (expand-file-name x dir) (1- depth)))
                      (seq-filter (lambda (x) (not (member x '("." ".."))))
                                  (directory-files dir)))))))))

(defun =pulumi-module-path-map ()
  (let ((m (make-hash-table :test #'equal))
        (root (=pulumi-go-src-root)))
    (mapc
     (lambda (dir)
       (let* ((p (expand-file-name dir root))
             (path-and-mods (=pulumi-go-modules p 2)))
         (while path-and-mods
           (puthash (cadr path-and-mods) (car path-and-mods) m)
           (setq path-and-mods (cddr path-and-mods)))))
     (=pulumi-go-projects))
    m))

(defun =pulumi-replace (&optional arg)
  "Insert the appropriate `replace` directive for a pulumi project."
  (interactive
   (list (completing-read "Select replace target: "
                          (=pulumi-module-path-map)
                          nil t)))
  (insert "replace " arg " => "
          (file-relative-name
           (gethash arg (=pulumi-module-path-map)))
          "\n"))
#+END_SRC

** Custom framework

In general, we want all customizations to occur in =init.org=. Since there is no obvious way to non-destructively disable =custom=, we set it to use an external file: =custom.el=.

#+BEGIN_SRC emacs-lisp
(setq custom-file (expand-file-name "custom.el" user-emacs-directory))
#+END_SRC

Customizations aren't loaded by default, so we also need to instruct Emacs to load =custom.el= if it exists.

#+BEGIN_SRC emacs-lisp
(when (file-exists-p custom-file)
  (load custom-file))
#+END_SRC

* Zsh

=zsh= has multiple startup files. According to [[https://zsh.sourceforge.io/Intro/intro_3.html][the documentation]], the load order goes like this

|--------------------+----------------------------|
| Name               | Condition                  |
|--------------------+----------------------------|
| $ZDOTDIR/.zshenv   | Always                     |
| $ZDOTDIR/.zprofile | Login shells only          |
| $ZDOTDIR/.zshrc    | Interactive shells only    |
| $ZDOTDIR/.zlogin   | Login shells only          |
| $ZDOTDIR/.zlogout  | Login shells only, on exit |
|--------------------+----------------------------|

** Literate Configuration
Obligatory =.gitignore= entry.

#+BEGIN_SRC .gitignore
.zshrc
.zshenv
#+END_SRC

All =zsh= files need to begin with a shebang.

#+BEGIN_SRC emacs-lisp
(=config-tangle-finalize (or (:name .zshrc)
			     (:name .zshenv)
			     (:ext .zsh))
  (goto-char (point-min))
  (insert "#!/bin/zsh\n\n"))
#+END_SRC

Emacs has [[help:sh-mode][sh-mode]], but no =zsh-mode=. Unfortunately, =org-mode= expects a mode called =zsh-mode= when activating [[help:org-edit-special][org-edit-special]]. Since the built-in =zsh-mode= can handle =.zsh= files just fine, we fake it.

#+BEGIN_SRC emacs-lisp
(defalias 'zsh-mode 'org-mode)
#+END_SRC

** =$PATH= and the Environment

We want to set =$PATH= in =.zshenv=, and set aliases in =.zshrc=.

=zsh= has a utility to declare a variable as a list of unique values. This describes =$PATH= perfectly.

#+BEGIN_SRC zsh :tangle .zshenv
typeset -U path
#+END_SRC

We now want to set the path to interact with various programs we have installed. To keep the =.zshenv= file clean, we only want to set the path when the associated files exist. For clarity, we define two simple helper functions:

#+BEGIN_SRC zsh :tangle .zshenv
# exa_exists <executable>
function exe_exists {
    type "$1" > /dev/null;
    return $?;
}

# add_to_path <path>
function add_to_path {
    path=("$1" "$path[@]")
}
#+END_SRC

We now use those to set up the path.

#+BEGIN_SRC zsh :tangle .zshenv
if [[ -f "$HOME/.cargo/env" ]]; then
    source "$HOME/.cargo/env"
fi

if exe_exists go; then
    export GOPATH="$HOME/go"
    export GOBIN="$GOPATH/bin"
    add_to_path "$GOBIN"
fi

if exe_exists dotnet; then
    add_to_path "$HOME/.dotnet/tools"
fi

export EDITOR='emacs -nw'
#+END_SRC

** Aliases

#+BEGIN_SRC zsh
alias aws-login='aws sso login --profile=dev-sandbox && eval $(aws-sso-creds export -p dev-sandbox)'
#+END_SRC

#+BEGIN_SRC zsh
if exe_exists exa; then
    alias ls='exa -Fl'
else
    alias ls='ls -Fl'
fi

alias cl='clear; ls'

if exe_exists gmake; then
    alias make=gmake
fi
#+END_SRC

** Prompt

I use [[https://starship.rs][starship]] for a useful contextual prompt. Initializing =starship= is easy:

#+BEGIN_SRC zsh
if exe_exists starship; then
    eval "$(starship init zsh)"
fi
#+END_SRC

=starship= is fully configured from =.config/starship.toml=.

#+BEGIN_SRC toml :tangle .config/starship.toml
# Don't add a newline at the end
add_newline = false

[character]
success_symbol = "[𝛌](bold green)"
error_symbol = ""

[status]
disabled = false
style = "bold red"
symbol = "𝛌"
format = "[$symbol\\($status\\)]($style)"
#+END_SRC

** Syntax Highlighting

#+BEGIN_SRC zsh
local HIGHLIGHT="$HOME/.cache/zsh-syntax-highlighting"
if ! [[ -d "$HIGHLIGHT" ]]; then
    echo "Cloning zsh syntax highlighting into $HIGHLIGHT"
    mkdir -d "$HOME/.cache"
    git clone 'https://github.com/zsh-users/zsh-syntax-highlighting.git' "$HIGHLIGHT"
fi
source $HIGHLIGHT/zsh-syntax-highlighting.zsh
#+END_SRC
